<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>更换电脑,hexo不能正常使用</title>
    <link href="/2021-10-31-%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91,hexo%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
    <url>/2021-10-31-%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91,hexo%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="更换电脑-hexo不能正常使用"><a href="#更换电脑-hexo不能正常使用" class="headerlink" title="更换电脑,hexo不能正常使用"></a>更换电脑,hexo不能正常使用</h1><p>新出的M1pro芯片肯定是吸引我的(真的香),果断换了,当弄到hexo发布博客的时间出现了权限不足的问题,我果断sudo执行命令,可是还是不行,老的Mac是可以的….三个小时后找到了解决办法!!!</p><p>首先先sudo执行hexo g的命令,如果报错讲根目录下的.deploy_git删除掉,继续hexo g就ok了</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hooks分享</title>
    <link href="/2021-05-08-hooks%E5%88%86%E4%BA%AB/"/>
    <url>/2021-05-08-hooks%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么会出现hooks-如何使用hooks"><a href="#为什么会出现hooks-如何使用hooks" class="headerlink" title="为什么会出现hooks,如何使用hooks?"></a>为什么会出现hooks,如何使用hooks?</h1><blockquote><p>我们现在的局面是这样的：</p><ul><li>React很受欢迎。</li><li>React组件使用类创建，因为这是当时最有意义的方式。</li><li>使用super(props)是很烦人的。</li><li>没人知道“this”是怎么回事。</li><li>好了冷静点。我假设你知道“this”是怎么回事，但这对某些人来说是不必要的障碍。</li><li>通过生命周期方法组织组件，迫使我们将相关的逻辑分散到组件中。</li><li>React对于共享非可视逻辑没有很好的原始支持。</li></ul></blockquote><h2 id="一-hooks的由来以及使用hooks的好处"><a href="#一-hooks的由来以及使用hooks的好处" class="headerlink" title="一.hooks的由来以及使用hooks的好处"></a>一.hooks的由来以及使用hooks的好处</h2><h3 id="1-this"><a href="#1-this" class="headerlink" title="1.this"></a>1.this</h3><p>首先他解决的就是this问题,例如我们常常在constructor中的bind一个事件来改变this的指向.在函数组件就可以.摆脱了this!!!!   : )</p><h3 id="2-解决props不明确"><a href="#2-解决props不明确" class="headerlink" title="2.解决props不明确"></a>2.解决props不明确</h3><p>因为有的class组件需要被很多高阶组件嵌套,导致传下来的props不知道是谁传的,或者props重名就会被覆盖掉,回调地狱见过吧,这…..</p><pre><code class="hljs jsx">&lt;WithHover&gt;  &lt;WithTheme hovering=&#123;<span class="hljs-literal">false</span>&#125;&gt;    &lt;WithAuth hovering=&#123;<span class="hljs-literal">false</span>&#125; theme=<span class="hljs-string">'dark'</span>&gt;      &lt;WithRepos hovering=&#123;<span class="hljs-literal">false</span>&#125; theme=<span class="hljs-string">'dark'</span> authed=&#123;<span class="hljs-literal">true</span>&#125;&gt;        &lt;Profile           id=<span class="hljs-string">'JavaScript'</span>          loading=&#123;<span class="hljs-literal">true</span>&#125;           repos=&#123;[]&#125;          authed=&#123;<span class="hljs-literal">true</span>&#125;          theme=<span class="hljs-string">'dark'</span>          hovering=&#123;<span class="hljs-literal">false</span>&#125;        /&gt;      &lt;<span class="hljs-regexp">/WithRepos&gt;</span><span class="hljs-regexp">    &lt;/</span>WithAuth&gt;  &lt;WithTheme&gt;&lt;<span class="hljs-regexp">/WithHover&gt;</span></code></pre><h3 id="3-重复代码"><a href="#3-重复代码" class="headerlink" title="3.重复代码"></a>3.重复代码</h3><p>Class component</p><pre><code class="hljs jsx">componentDidMount () &#123;   <span class="hljs-keyword">this</span>.updateRepos(<span class="hljs-keyword">this</span>.props.id) &#125; componentDidUpdate (prevProps) &#123;   <span class="hljs-keyword">if</span> (prevProps.id !== <span class="hljs-keyword">this</span>.props.id) &#123;     <span class="hljs-keyword">this</span>.updateRepos(<span class="hljs-keyword">this</span>.props.id)   &#125; &#125; updateRepos = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;.... &#125;</code></pre><p>hooks</p><pre><code class="hljs jsx">React.useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  updateRepos(props.id)&#125;, [props.id])<span class="hljs-keyword">const</span> updateRepos = React.useCallback(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;  .....&#125;, [])</code></pre><h3 id="4-解决逻辑不清晰问题"><a href="#4-解决逻辑不清晰问题" class="headerlink" title="4.解决逻辑不清晰问题"></a>4.解决逻辑不清晰问题</h3><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> Index = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [dataList, setDataList] = React.useState([]);  <span class="hljs-keyword">const</span> [pageNum, setPageNum] = React.useState(<span class="hljs-number">1</span>);  <span class="hljs-keyword">const</span> [currentTotal, setCurrentTotal] = React.useState(<span class="hljs-number">0</span>);<span class="hljs-comment">// 改变tab</span>  <span class="hljs-keyword">const</span> &#123; tabIndex, onClick &#125; = useTabChange(setDataList, setPageNum);<span class="hljs-comment">// 加载更多</span>  <span class="hljs-keyword">const</span> &#123; hasMore, onLoadMore &#125; = useLoadMore(    currentTotal,    pageNum,    tabIndex,    dataList,    setDataList,    setCurrentTotal,    setPageNum  );<span class="hljs-comment">// 获取屏幕剩余宽度</span>  <span class="hljs-keyword">const</span> &#123; remainingHeight &#125; = useWindowHeight(props.takeUpHeight);<span class="hljs-comment">// 渲染底部</span>  <span class="hljs-keyword">const</span> renderFooter = React.useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListFooter</span> /&gt;</span></span>;  &#125;, []);<span class="hljs-comment">// 渲染每行</span>  <span class="hljs-keyword">const</span> renderItem = React.useCallback(    (item) =&gt; &#123;      <span class="hljs-keyword">return</span> (        &lt;ListItem          &#123;...item&#125;          imgSrc=&#123;item.imageUrl&#125;          company=&#123;item.basic.companyName&#125;          title=&#123;item.basic.insureName&#125;          tag=&#123;tabList[tabIndex].title&#125;          detail=&#123;item.desc&#125;          price=&#123;item.minPremiumE2&#125;        /&gt;      );    &#125;,    [tabIndex]  );<span class="hljs-comment">// 当tab发生改变进行请求</span>  React.useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    callApiBase(lhjApi.query_domestic_list, &#123;      params: &#123;        type: tabList[tabIndex].type,        pageNo: <span class="hljs-number">1</span>,      &#125;,    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      setDataList(res.data?.list ?? []);      setCurrentTotal(res.data?.total ?? <span class="hljs-number">0</span>);      setPageNum(<span class="hljs-number">2</span>);    &#125;);  &#125;, [tabIndex]);  <span class="hljs-keyword">return</span> (    &lt;View className=<span class="hljs-string">'domestic-insurance-namespace'</span>&gt;      &lt;AtTabs        current=&#123;tabIndex&#125;        scroll        height=&#123;remainingHeight&#125;        tabDirection=<span class="hljs-string">'vertical'</span>        tabList=&#123;tabList&#125;        onClick=&#123;onClick&#125;      &gt;        &#123;tabList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;          <span class="hljs-keyword">return</span> (            &lt;AtTabsPane              tabDirection=<span class="hljs-string">'vertical'</span>              key=&#123;item.type&#125;              current=&#123;tabIndex&#125;              index=&#123;index&#125;            &gt;              &lt;ListView                style=&#123;&#123;                  height: remainingHeight,                &#125;&#125;                list=&#123;dataList&#125;                renderItem=&#123;renderItem&#125;                renderFooter=&#123;renderFooter&#125;                onLoadMore=&#123;onLoadMore&#125;                hasMore=&#123;hasMore&#125;              /&gt;            &lt;<span class="hljs-regexp">/AtTabsPane&gt;</span><span class="hljs-regexp">          );</span><span class="hljs-regexp">        &#125;)&#125;</span><span class="hljs-regexp">      &lt;/</span>AtTabs&gt;    &lt;<span class="hljs-regexp">/View&gt;</span><span class="hljs-regexp">  );</span><span class="hljs-regexp">&#125;;</span></code></pre><h2 id="二-使用事项"><a href="#二-使用事项" class="headerlink" title="二.使用事项"></a>二.使用事项</h2><blockquote><ul><li><p>不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。<a href="https://evanchen0629.github.io/2019-09-18-%E4%BB%8Ereact-hooks%E2%80%9C%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1%E2%80%9D%E5%88%87%E5%85%A5%EF%BC%8C%E6%B5%85%E8%B0%88react-hooks/" target="_blank" rel="noopener">具体可看这里</a>,大致解释一下,因为react在遇见hooks的时候会将他们统一存到链表中,每一次视图更新,这个链表也会更新,因为是依赖上一次的链表中对应的值</p></li><li><p>只能在React函数式组件或自定义Hook中使用Hook。(想在class中使用hooks也有骚操作,例如用函数组件将类组件包裹起来,在函数组件中使用hooks,通过props传递给类组件就好了……但是极其不建议)</p></li><li><p>不要在useEffect()第一个参数使用async,因为第一个参数返回的闭包函数是卸载组件调用的,用async返回的闭包函数就是promise了</p></li></ul></blockquote><h3 id="三-useCallback和useMemo的区别"><a href="#三-useCallback和useMemo的区别" class="headerlink" title="三.useCallback和useMemo的区别"></a>三.useCallback和useMemo的区别</h3><p>这两个东西是做性能优化的</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> [num, setNum] = React.useState(<span class="hljs-number">0</span>);  <span class="hljs-comment">// const a = () =&gt; &#123;</span>      <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">const</span> a = React.useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  &#125;, [])  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&#123;a&#125;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(num+1)&#125; &gt;按我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>&#123;  React.useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  &#125;, [props.a])  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;</code></pre><p>使用callback时就会打印一次1,当使用箭头函数或者普通函数时当num更改时,就会打印一次1,so使用callback是对性能优化…</p><p>而memo和callback必须有返回值,类似vue中的computed,做大量数据运算时使用</p><ul><li>useCallback 优化针对于子组件渲染</li><li>useMemo 优化针对于当前组件高开销的计算</li></ul><h3 id="四-hook中的setState是同步还是异步的"><a href="#四-hook中的setState是同步还是异步的" class="headerlink" title="四.hook中的setState是同步还是异步的?"></a>四.hook中的setState是同步还是异步的?</h3><p>准确来说当state变化时函数会重新走一遍,所以说同步异步没关系,想要拿到最新数据只需要在依赖写上state,当state变化时,函数也自然变化,useeffect也会重新走</p><blockquote><p>剩下的几个hooks没有什么注意点吧….待更ing(遇见问题会更新)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react根据环境更改title</title>
    <link href="/2021-02-21-react%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E6%9B%B4%E6%94%B9title/"/>
    <url>/2021-02-21-react%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E6%9B%B4%E6%94%B9title/</url>
    
    <content type="html"><![CDATA[<h1 id="react根据环境更改title"><a href="#react根据环境更改title" class="headerlink" title="react根据环境更改title"></a>react根据环境更改title</h1><p>通过create react app 创建的项目可以直接更改public中的index.html中的title替换成<code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv6tnigb8j30hd010q2w.jpg" srcset="/img/loading.gif" alt="image-20210221152847857"></p><p>接下来在config下的webpack.config.js中该更如下代码</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> HtmlWebpackPlugin(  <span class="hljs-built_in">Object</span>.assign(    &#123;&#125;,    &#123;      inject: <span class="hljs-literal">true</span>,      template: paths.appHtml,    &#125;,    isEnvProduction      ? &#123;          minify: &#123;            removeComments: <span class="hljs-literal">true</span>,            collapseWhitespace: <span class="hljs-literal">true</span>,            removeRedundantAttributes: <span class="hljs-literal">true</span>,            useShortDoctype: <span class="hljs-literal">true</span>,            removeEmptyAttributes: <span class="hljs-literal">true</span>,            removeStyleLinkTypeAttributes: <span class="hljs-literal">true</span>,            keepClosingSlash: <span class="hljs-literal">true</span>,            minifyJS: <span class="hljs-literal">true</span>,            minifyCSS: <span class="hljs-literal">true</span>,            minifyURLs: <span class="hljs-literal">true</span>,          &#125;,          title: <span class="hljs-string">'DMP'</span>        &#125;      : &#123;          title: <span class="hljs-string">'开发环境'</span>        &#125;  )),</code></pre><p>ok了</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async和await的演变过程</title>
    <link href="/2021-2-1-async%E5%92%8Cawait%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
    <url>/2021-2-1-async%E5%92%8Cawait%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在工作大家经常使用async和await,例如模拟个异步,a里面存着b的路径,b存着c的路径,我想要得到c里面的内容,就必须一层层读,如何让大家写肯定会想到async和await的,那他又是怎么来的呢?</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn832pihekj306001zwea.jpg" srcset="/img/loading.gif" alt="image-20210201155107986"></p><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readSync</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> value1 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">'./a.txt'</span>, <span class="hljs-string">'utf-8'</span>)  <span class="hljs-keyword">let</span> value2 = <span class="hljs-keyword">await</span> readFile(value1, <span class="hljs-string">'utf-8'</span>);  <span class="hljs-keyword">let</span> value3 = <span class="hljs-keyword">await</span> readFile(value2, <span class="hljs-string">'utf-8'</span>);&#125;</code></pre><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>首先讲一下es6非常关键的东西迭代器,简单的说可以用for of语句执行的就是可迭代对象,可迭代对象中都实现了迭代器,例如数组,Map,字符串NodeList……</p><p>在简单点说可以看原型链上有没有这个属性</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn837tm9aij30u00vq7aw.jpg" srcset="/img/loading.gif" alt="image-20210201155604914"></p><p>那这个时候我们用for of就可以打印迭代他</p><p><strong>这里要注意迭代,遍历和循环的区别</strong></p><ul><li><p>循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。</p></li><li><p>迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。</p></li><li><p>遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</p></li></ul><h2 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h2><p>生成器其实就是生成迭代器的</p><p>语法</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">name</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>&#125;</code></pre><p>和return的区别是,return在函数中只有一个,而yield可以有多个,return直接终止函数了,而yield可以理解为暂停函数</p><p>使用</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generate</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value: '</span>, value);  <span class="hljs-keyword">yield</span> value  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">const</span> iter = generate()<span class="hljs-built_in">console</span>.log(iter.next());<span class="hljs-built_in">console</span>.log(iter.next(<span class="hljs-number">2</span>));<span class="hljs-built_in">console</span>.log(iter.next());</code></pre><p>1.首先创建一个生成器对象</p><p>2.通过生成器对象调用next方法来执行函数,到第一个yield结束,多次调用next可以多次执行</p><p>3.next可以传递参数,传递的参数可以通过yield的返回值接收,第一次传值是接收不到的,而是第二个传递才能接收到例如:</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn83ndt6xaj30oo0d4mz0.jpg" srcset="/img/loading.gif" alt="image-20210201161101960"></p><p>普及了这些就可以实现async和await了</p><h2 id="3-通过例子来实现async和await"><a href="#3-通过例子来实现async和await" class="headerlink" title="3.通过例子来实现async和await"></a>3.通过例子来实现async和await</h2><p>我们先通过promise解决回调地狱的问题</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)<span class="hljs-keyword">const</span> readSync = <span class="hljs-function">(<span class="hljs-params">pathName</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;    fs.readFile(pathName, <span class="hljs-string">'utf-8'</span>, (err, data) =&gt; &#123;      <span class="hljs-keyword">if</span> (err) &#123;        reject(err)      &#125;      resolve(data)    &#125;)  &#125;)&#125;<span class="hljs-keyword">const</span> p1 = readSync(<span class="hljs-string">'./a.txt'</span>)p1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> readSync(res)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> readSync(res)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// 会打印c.txt中的内容</span>&#125;)</code></pre><p>这时候我们可以创建一个生成器去读取文件,在创建一个执行器去执行生成器</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">readFile</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">yield</span> readSync(<span class="hljs-string">'./a.txt'</span>)  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">yield</span> readSync(res1)  <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">yield</span> readSync(res2)  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'res3: '</span>, res3);&#125;<span class="hljs-keyword">const</span> iter = readFile()<span class="hljs-keyword">const</span> &#123;value, done&#125; = iter.next();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done: '</span>, done);value.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123;value, done&#125; = iter.next(res);  value.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123;value, done&#125; =iter.next(res);    value.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> &#123;value, done&#125; = iter.next(res)    &#125;)  &#125;)&#125;)</code></pre><p>这样这个readFile函数就会打印c.txt中的内容了,是不是感觉每次写生成器很不爽,我们借鉴TJ大神写的生成器,简单封装一个通用的生成器代码</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Co</span>(<span class="hljs-params">iter</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> next = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;      <span class="hljs-keyword">let</span> &#123; value, done &#125; = iter.next(data);      <span class="hljs-keyword">if</span> (done) &#123;        resolve(data);      &#125; <span class="hljs-keyword">else</span> &#123;        value.then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;          next(val)        &#125;, reject)      &#125;    &#125;    next();  &#125;)&#125;Co(iter)</code></pre><p>这样就ok了,然后咱们看这段代码,对比一下,大家是不是就知道async和await的由来了 😁</p><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readSync</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> value1 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">'./a.txt'</span>, <span class="hljs-string">'utf-8'</span>)  <span class="hljs-keyword">let</span> value2 = <span class="hljs-keyword">await</span> readFile(value1, <span class="hljs-string">'utf-8'</span>);  <span class="hljs-keyword">let</span> value3 = <span class="hljs-keyword">await</span> readFile(value2, <span class="hljs-string">'utf-8'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">readFile</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">yield</span> readSync(<span class="hljs-string">'./a.txt'</span>)  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">yield</span> readSync(res1)  <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">yield</span> readSync(res2)&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬砖中所遇到的问题</title>
    <link href="/2021-1-29-%E6%90%AC%E7%A0%96%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021-1-29-%E6%90%AC%E7%A0%96%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-typescript-eslint-no-unused-vars"><a href="#1-typescript-eslint-no-unused-vars" class="headerlink" title="1.@typescript-eslint/no-unused-vars"></a>1.@typescript-eslint/no-unused-vars</h2><p>当没有使用变量的时候,eslint会报一个这个错,聪明的你肯定想到,我没用到我删了不就行了嘛😑</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> handleChange = React.useCallback(    (      currentPagination: <span class="hljs-built_in">any</span>,      filteredInfo: &#123; [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>[] &#125;,      currentSortInfo: ITableSortInfo,      params?: <span class="hljs-built_in">any</span>    ) =&gt; &#123;    [_setPagination, pagination, sortInfo]  );</code></pre><p>当我定义一个函数的时候,我不确定外面给不给我传这个参数,当然已经是个很老的项目了,如果删掉的话,会出现很多问题,还有改当前已有的项目所使用的地方.</p><ul><li><p>解决办法</p><p>在参数名前面加上一个_,就可以解决eslint报的错了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript如何在 React 中完美运用？</title>
    <link href="/2020-5-29-TypeScript%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E4%B8%AD%E5%AE%8C%E7%BE%8E%E8%BF%90%E7%94%A8%EF%BC%9F/"/>
    <url>/2020-5-29-TypeScript%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E4%B8%AD%E5%AE%8C%E7%BE%8E%E8%BF%90%E7%94%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="组件-Props"><a href="#组件-Props" class="headerlink" title="组件 Props"></a>组件 Props</h2><p>先看几种定义 Props 经常用到的类型：</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><pre><code class="hljs ts"><span class="hljs-keyword">type</span> BasicProps = &#123;  message: <span class="hljs-built_in">string</span>;  count: <span class="hljs-built_in">number</span>;  disabled: <span class="hljs-built_in">boolean</span>;  <span class="hljs-comment">/** 数组类型 */</span>  names: <span class="hljs-built_in">string</span>[];  <span class="hljs-comment">/** 用「联合类型」限制为下面两种「字符串字面量」类型 */</span>  status: <span class="hljs-string">"waiting"</span> | <span class="hljs-string">"success"</span>;&#125;;</code></pre><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ObjectOrArrayProps = &#123;  <span class="hljs-comment">/** 如果你不需要用到具体的属性 可以这样模糊规定是个对象 ❌ 不推荐 */</span>  obj: object;  obj2: &#123;&#125;; <span class="hljs-comment">// 同上</span>  <span class="hljs-comment">/** 拥有具体属性的对象类型 ✅ 推荐 */</span>  obj3: &#123;    id: <span class="hljs-built_in">string</span>;    title: <span class="hljs-built_in">string</span>;  &#125;;  <span class="hljs-comment">/** 对象数组 😁 常用 */</span>  objArr: &#123;    id: <span class="hljs-built_in">string</span>;    title: <span class="hljs-built_in">string</span>;  &#125;[];  <span class="hljs-comment">/** key 可以为任意 string，值限制为 MyTypeHere 类型 */</span>  dict1: &#123;    [key: <span class="hljs-built_in">string</span>]: MyTypeHere;  &#125;;  dict2: Record&lt;<span class="hljs-built_in">string</span>, MyTypeHere&gt;; <span class="hljs-comment">// 基本上和 dict1 相同，用了 TS 内置的 Record 类型。</span>&#125;</code></pre><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><pre><code class="hljs ts"><span class="hljs-keyword">type</span> FunctionProps = &#123;  <span class="hljs-comment">/** 任意的函数类型 ❌ 不推荐 不能规定参数以及返回值类型 */</span>  onSomething: <span class="hljs-built_in">Function</span>;  <span class="hljs-comment">/** 没有参数的函数 不需要返回值 😁 常用 */</span>  onClick: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>;  <span class="hljs-comment">/** 带函数的参数 😁 非常常用 */</span>  onChange: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;  <span class="hljs-comment">/** 另一种函数语法 参数是 React 的按钮事件 😁 非常常用 */</span>  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): <span class="hljs-built_in">void</span>;  <span class="hljs-comment">/** 可选参数类型 😁 非常常用 */</span>  optional?: OptionalType;&#125;</code></pre><h3 id="React-相关类型"><a href="#React-相关类型" class="headerlink" title="React 相关类型"></a>React 相关类型</h3><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> AppProps &#123;  children1: JSX.Element; <span class="hljs-comment">// ❌ 不推荐 没有考虑数组</span>  children2: JSX.Element | JSX.Element[]; <span class="hljs-comment">// ❌ 不推荐 没有考虑字符串 children</span>  children4: React.ReactChild[]; <span class="hljs-comment">// 稍微好点 但是没考虑 null</span>  children: React.ReactNode; <span class="hljs-comment">// ✅ 包含所有 children 情况</span>  functionChildren: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> React.ReactNode; <span class="hljs-comment">// ✅ 返回 React 节点的函数</span>  style?: React.CSSProperties; <span class="hljs-comment">// ✅ 推荐 在内联 style 时使用</span>  <span class="hljs-comment">// ✅ 推荐原生 button 标签自带的所有 props 类型</span>  <span class="hljs-comment">// 也可以在泛型的位置传入组件 提取组件的 Props 类型</span>  props: React.ComponentProps&lt;<span class="hljs-string">"button"</span>&gt;;  <span class="hljs-comment">// ✅ 推荐 利用上一步的做法 再进一步的提取出原生的 onClick 函数类型 </span>  <span class="hljs-comment">// 此时函数的第一个参数会自动推断为 React 的点击事件类型</span>  onClickButton：React.ComponentProps&lt;<span class="hljs-string">"button"</span>&gt;[<span class="hljs-string">"onClick"</span>]&#125;</code></pre><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>最简单的：</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> AppProps = &#123; message: <span class="hljs-built_in">string</span> &#125;;<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">&#123; message &#125;: AppProps</span>) =&gt;</span> &lt;div&gt;&#123;message&#125;&lt;<span class="hljs-regexp">/div&gt;;</span></code></pre><p>包含 children 的：</p><p>利用 <code>React.FC</code> 内置类型的话，不光会包含你定义的 <code>AppProps</code> 还会自动加上一个 children 类型，以及其他组件上会出现的类型：</p><pre><code class="hljs ts"><span class="hljs-comment">// 等同于</span>AppProps &amp; &#123;   children: React.ReactNode   propTypes?: WeakValidationMap&lt;P&gt;;  contextTypes?: ValidationMap&lt;<span class="hljs-built_in">any</span>&gt;;  defaultProps?: Partial&lt;P&gt;;  displayName?: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">interface</span> AppProps = &#123; message: <span class="hljs-built_in">string</span> &#125;;<span class="hljs-keyword">const</span> App: React.FC&lt;AppProps&gt; = <span class="hljs-function">(<span class="hljs-params">&#123; message, children &#125;</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    &lt;&gt;     &#123;children&#125;     &lt;div&gt;&#123;message&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;/</span>&gt;  )&#125;;</code></pre><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><code>@types/react</code> 包在 16.8 以上的版本开始对 Hooks 的支持。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>如果你的默认值已经可以说明类型，那么不用手动声明类型，交给 TS 自动推断即可：</p><pre><code class="hljs ts"><span class="hljs-comment">// val: boolean</span><span class="hljs-keyword">const</span> [val, toggle] = React.useState(<span class="hljs-literal">false</span>);toggle(<span class="hljs-literal">false</span>)toggle(<span class="hljs-literal">true</span>)</code></pre><p>如果初始值是 null 或 undefined，那就要通过泛型手动传入你期望的类型。</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [user, setUser] = React.useState&lt;IUser | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<span class="hljs-comment">// later...</span>setUser(newUser);</code></pre><p>这样也可以保证在你直接访问 <code>user</code> 上的属性时，提示你它有可能是 null。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f3eb300d824bafb544494b8e92d9ac~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="img"></p><p>通过 <code>optional-chaining</code> 语法（TS 3.7 以上支持），可以避免这个错误。</p><pre><code class="hljs ts"><span class="hljs-comment">// ✅ ok</span><span class="hljs-keyword">const</span> name = user?.name</code></pre><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>需要用 <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions" target="_blank" rel="noopener">Discriminated Unions</a> 来标注 Action 的类型。</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> initialState = &#123; count: <span class="hljs-number">0</span> &#125;;<span class="hljs-keyword">type</span> ACTIONTYPE =  | &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">"increment"</span>; payload: <span class="hljs-built_in">number</span> &#125;  | &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">"decrement"</span>; payload: <span class="hljs-built_in">string</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state: <span class="hljs-keyword">typeof</span> initialState, action: ACTIONTYPE</span>) </span>&#123;  <span class="hljs-keyword">switch</span> (action.type) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">"increment"</span>:      <span class="hljs-keyword">return</span> &#123; count: state.count + action.payload &#125;;    <span class="hljs-keyword">case</span> <span class="hljs-string">"decrement"</span>:      <span class="hljs-keyword">return</span> &#123; count: state.count - <span class="hljs-built_in">Number</span>(action.payload) &#125;;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> [state, dispatch] = React.useReducer(reducer, initialState);  <span class="hljs-keyword">return</span> (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick=&#123;<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(&#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">"decrement"</span>, payload: <span class="hljs-string">"5"</span> &#125;)&#125;&gt;        -      &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "increment", payload: 5 &#125;)&#125;&gt;</span><span class="hljs-regexp">        +</span><span class="hljs-regexp">      &lt;/</span>button&gt;    &lt;<span class="hljs-regexp">/&gt;</span><span class="hljs-regexp">  );</span><span class="hljs-regexp">&#125;</span></code></pre><p>「Discriminated Unions」一般是一个联合类型，其中每一个类型都需要通过类似 <code>type</code> 这种特定的字段来区分，当你传入特定的 <code>type</code> 时，剩下的类型 <code>payload</code> 就会自动匹配推断。</p><p>这样：</p><ul><li>当你写入的 <code>type</code> 匹配到 <code>decrement</code> 的时候，TS 会自动推断出相应的 <code>payload</code> 应该是 <code>string</code> 类型。</li><li>当你写入的 <code>type</code> 匹配到 <code>increment</code> 的时候，则 <code>payload</code> 应该是 <code>number</code> 类型。</li></ul><p>这样在你 <code>dispatch</code> 的时候，输入对应的 <code>type</code>，就自动提示你剩余的参数类型啦。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>这里主要需要注意的是，useEffect 传入的函数，它的返回值要么是一个<strong>方法</strong>（清理函数），要么就是<strong>undefined</strong>，其他情况都会报错。</p><p>比较常见的一个情况是，我们的 useEffect 需要执行一个 async 函数，比如：</p><pre><code class="hljs ts"><span class="hljs-comment">// ❌ </span><span class="hljs-comment">// Type 'Promise&lt;void&gt;' provides no match </span><span class="hljs-comment">// for the signature '(): void | undefined'</span>useEffect(<span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUser()  setUser(user)&#125;, [])</code></pre><p>虽然没有在 async 函数里显式的返回值，但是 async 函数默认会返回一个 Promise，这会导致 TS 的报错。</p><p>推荐这样改写：</p><pre><code class="hljs ts">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> getUser = <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUser()    setUser(user)  &#125;  getUser()&#125;, [])</code></pre><p>或者用自执行函数？不推荐，可读性不好。</p><pre><code class="hljs ts">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  (<span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUser()    setUser(user)  &#125;)()&#125;, [])</code></pre><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>这个 Hook 在很多时候是没有初始值的，这样可以声明返回对象中 <code>current</code> 属性的类型：</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> ref2 = useRef&lt;HTMLElement&gt;(<span class="hljs-literal">null</span>);</code></pre><p>以一个按钮场景为例：</p><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> inputEl = React.useRef&lt;HTMLInputElement&gt;(<span class="hljs-literal">null</span>);  <span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (inputEl &amp;&amp; inputEl.current) &#123;      inputEl.current.focus();    &#125;  &#125;;  <span class="hljs-keyword">return</span> (    &lt;&gt;      &lt;input ref=&#123;inputEl&#125; <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span> /&gt;      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">    &lt;/</span>&gt;  );&#125;</code></pre><p>当 <code>onButtonClick</code> 事件触发时，可以肯定 <code>inputEl</code> 也是有值的，因为组件是同级别渲染的，但是还是依然要做冗余的非空判断。</p><p>有一种办法可以绕过去。</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> ref1 = useRef&lt;HTMLElement&gt;(<span class="hljs-literal">null</span>!);</code></pre><p><code>null!</code> 这种语法是非空断言，跟在一个值后面表示你断定它是有值的，所以在你使用 <code>inputEl.current.focus()</code> 的时候，TS 不会给出报错。</p><p>但是这种语法比较危险，需要尽量减少使用。</p><p>在绝大部分情况下，<code>inputEl.current?.focus()</code> 是个更安全的选择，除非这个值<strong>真的不可能</strong>为空。（比如在使用之前就赋值了）</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>推荐使用一个自定义的 <code>innerRef</code> 来代替原生的 <code>ref</code>，否则要用到 <code>forwardRef</code> 会搞的类型很复杂。</p><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ListProps = &#123;  innerRef?: React.Ref&lt;&#123; scrollToTop(): <span class="hljs-built_in">void</span> &#125;&gt;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">props: ListProps</span>) </span>&#123;  useImperativeHandle(props.innerRef, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;    scrollToTop() &#123; &#125;  &#125;))  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre><p>结合刚刚 <code>useRef</code> 的知识，使用是这样的：</p><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Use</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> listRef = useRef&lt;&#123; scrollToTop(): <span class="hljs-built_in">void</span> &#125;&gt;(<span class="hljs-literal">null</span>!)  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    listRef.current.scrollToTop()  &#125;, [])  <span class="hljs-keyword">return</span> (    &lt;List innerRef=&#123;listRef&#125; /&gt;  )&#125;</code></pre><p>很完美，是不是？</p><p>可以在线调试 <a href="https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wEoFNkGN4BmUEIcA5FDvmQNwCwAUKJLHAN5wCuqWAyjMhhYANFx4BRAgSz5R3LNgJyeASXBYog4ADcsACWQA7ACYAbLHAC+cIiXKU8MWo0YwAnmAsAZYKhgAFYjB0AF52Rjg4YENDDUUAfgAuTCoYADpFAB4OVFxiU1MAFQhisAAKAEpk7QhgYysAPkZLFwYCTkN8YAhDOB8-MrAg1GT+gOGK8IZI+TVPTRgdfSMzLEHhtOjYqEVRSrgQhrgytgjIuFz8opKIcsmOFumrCoqzyhhOKF7DTgLm1vanUWPTgAFUePtTk9cD0-HBTL4YIoDmIFFgCNkLnkIAViqVKtVavVLA0yj8CgBCV4MM7ySTSfBlfaHKbneGIxRpXCfSiGdKXHHXfHUyKWUQAbQAutS3lgPl9jmdIpkxlEYnF0SE2Ai-IprAB6JpPamWIA" target="_blank" rel="noopener">useImperativeHandle 的例子</a>。</p><p>也可以查看这个<a href="https://github.com/typescript-cheatsheets/react/issues/106" target="_blank" rel="noopener">useImperativeHandle 讨论 Issue</a>，里面有很多有意思的想法，也有使用 React.forwardRef 的复杂例子。</p><h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h3><p>如果你想仿照 useState 的形式，返回一个数组给用户使用，一定要记得在适当的时候使用 <code>as const</code>，标记这个返回值是个常量，告诉 TS 数组里的值不会删除，改变顺序等等……</p><p>否则，你的每一项都会被推断成是「所有类型可能性的联合类型」，这会影响用户使用。</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useLoading</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> [isLoading, setState] = React.useState(<span class="hljs-literal">false</span>);  <span class="hljs-keyword">const</span> load = <span class="hljs-function">(<span class="hljs-params">aPromise: <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>) =&gt;</span> &#123;    setState(<span class="hljs-literal">true</span>);    <span class="hljs-keyword">return</span> aPromise.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setState(<span class="hljs-literal">false</span>));  &#125;;  <span class="hljs-comment">// ✅ 加了 as const 会推断出 [boolean, typeof load]</span>  <span class="hljs-comment">// ❌ 否则会是 (boolean | typeof load)[]</span>  <span class="hljs-keyword">return</span> [isLoading, load] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;[]&#125;</code></pre><p>对了，如果你在用 React Hook 写一个库，别忘了把类型也导出给用户使用。</p><h2 id="React-API"><a href="#React-API" class="headerlink" title="React API"></a>React API</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>函数式组件默认不可以加 ref，它不像类组件那样有自己的实例。这个 API 一般是函数式组件用来接收父组件传来的 ref。</p><p>所以需要标注好实例类型，也就是父组件通过 ref 可以拿到什么样类型的值。</p><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Props = &#123; &#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Ref = HTMLButtonElement;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FancyButton = React.forwardRef&lt;Ref, Props&gt;<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">props, ref</span>) =&gt; (<span class="hljs-params"></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">  &lt;button ref=&#123;ref&#125; className="MyClassName"&gt;</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">    &#123;props.children&#125;</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">  &lt;/button&gt;</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"></span>)</span>);</span></code></pre><p>由于这个例子里直接把 ref 转发给 button 了，所以直接把类型标注为 <code>HTMLButtonElement</code> 即可。</p><p>父组件这样调用，就可以拿到正确类型：</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> ref = useRef&lt;HTMLButtonElement&gt;()  <span class="hljs-keyword">return</span> (    &lt;FancyButton ref=&#123;ref&#125; /&gt;  )&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从react hooks“闭包陷阱”切入，浅谈react hooks</title>
    <link href="/2019-09-18-%E4%BB%8Ereact-hooks%E2%80%9C%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1%E2%80%9D%E5%88%87%E5%85%A5%EF%BC%8C%E6%B5%85%E8%B0%88react-hooks/"/>
    <url>/2019-09-18-%E4%BB%8Ereact-hooks%E2%80%9C%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1%E2%80%9D%E5%88%87%E5%85%A5%EF%BC%8C%E6%B5%85%E8%B0%88react-hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="从react-hooks“闭包陷阱”切入，浅谈react-hooks"><a href="#从react-hooks“闭包陷阱”切入，浅谈react-hooks" class="headerlink" title="从react hooks“闭包陷阱”切入，浅谈react hooks"></a>从react hooks“闭包陷阱”切入，浅谈react hooks</h1><p>首先，本文并不会讲解 hooks 的基本用法， 本文从 一个hooks中 “奇怪”（其实符合逻辑） 的 “闭包陷阱” 的场景切入，试图讲清楚其背后的因果。同时，在许多 react hooks 奇技淫巧的文章里，也能看到 <code>useRef</code> 的身影，那么为什么使用 <code>useRef</code> 又能摆脱 这个 “闭包陷阱” ？ 我想搞清楚这些问题，将能较大的提升对 react hooks 的理解。</p><p>react hooks 一出现便受到了许多开发人员的追捧,或许在使用react hooks 的时候遇到 “闭包陷阱” 是每个开发人员在开发的时候都遇到过的事情，有的两眼懵逼、有的则稳如老狗瞬间就定义到了问题出现在何处。</p><p>(以下react示范demo，均为react 16.8.3 版本)</p><p>你一定遭遇过以下这个场景：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">1</span>);    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(count)        &#125;, <span class="hljs-number">1000</span>)    &#125;, [])&#125;</code></pre><p>在这个定时器里面去打印 <code>count</code> 的值，会发现，不管在这个组件中的其他地方使用 <code>setCount</code> 将 <code>count</code> 设置为任何值，还是设置多少次，打印的都是1。是不是有一种，尽管历经千帆，我记得的还是你当初的模样的感觉？ hhh… 接下来，我将尽力的尝试将我理解的，为什么会发生这么个情况说清楚，并且浅谈一些hooks其他的特性。如果有错误，希望各位同学能救救孩子，不要让我带着错误的认知活下去了。。。</p><h2 id="1、一个熟悉的闭包场景"><a href="#1、一个熟悉的闭包场景" class="headerlink" title="1、一个熟悉的闭包场景"></a>1、一个熟悉的闭包场景</h2><p>首先从一个各位jser都很熟悉的场景入手。</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++ ) &#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(i)    &#125;, <span class="hljs-number">0</span>)&#125;</code></pre><p>想宝宝我刚刚毕业的那一年，这道题还是一道有些热门的面试题目。而如今…</p><p>我就不说为什么最终，打印的都是5的原因了。直接贴出使用闭包打印 0…4的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++ ) &#123;   (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;         setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(i)        &#125;, <span class="hljs-number">0</span>)   &#125;)(i)&#125;</code></pre><p>这个原理其实就是使用闭包，定时器的回调函数去引用立即执行函数里定义的变量，形成闭包保存了立即执行函数执行时 i 的值，异步定时器的回调函数才如我们想要的打印了顺序的值。</p><p>其实，<code>useEffect</code> 的哪个场景的原因，跟这个，简直是一样的，<strong><code>useEffect</code> 闭包陷阱场景的出现，是 react 组件更新流程以及 <code>useEffect</code> 的实现的自然而然结果</strong>。</p><h2 id="2-浅谈hooks原理，理解useEffect-的-“闭包陷阱”-出现原因。"><a href="#2-浅谈hooks原理，理解useEffect-的-“闭包陷阱”-出现原因。" class="headerlink" title="2 浅谈hooks原理，理解useEffect 的 “闭包陷阱” 出现原因。"></a>2 浅谈hooks原理，理解useEffect 的 “闭包陷阱” 出现原因。</h2><p>其实，很不想在写这篇文章的过程中，牵扯到react原理这方面的东西，因为真的是太整体了（其实主要原因是菜，自己也只是掌握的囫囵吞枣），你要明白这个大概的过程，你得明白支撑起这个大概的一些重要的点。</p><p>首先，可能都听过react的 Fiber 架构，其实一个 Fiber节点就对应的是一个组件。对于 <code>classComponent</code> 而言，有 <code>state</code> 是一件很正常的事情，Fiber对象上有一个 <code>memoizedState</code> 用于存放组件的 <code>state</code>。ok，现在看 hooks 所针对的 <code>FunctionComponnet</code>。 无论开发者怎么折腾，一个对象都只能有一个 <code>state</code> 属性或者 <code>memoizedState</code> 属性，可是，谁知道可爱的开发者们会在 <code>FunctionComponent</code> 里写上多少个 <code>useState</code>，<code>useEffect</code> 等等 ? 所以，react用了链表这种数据结构来存储 <code>FunctionComponent</code> 里面的 hooks。比如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">1</span>)    <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">'evanchen'</span>)    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            &#125;, [])    <span class="hljs-keyword">const</span> text = useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">'ddd'</span>    &#125;, [])&#125;</code></pre><p>在组件第一次渲染的时候，为每个hooks都创建了一个对象</p><pre><code class="hljs js">type Hook = &#123;  memoizedState: any,  baseState: any,  baseUpdate: Update&lt;any, any&gt; | <span class="hljs-literal">null</span>,  queue: UpdateQueue&lt;any, any&gt; | <span class="hljs-literal">null</span>,  next: Hook | <span class="hljs-literal">null</span>,&#125;;</code></pre><p>最终形成了一个链表。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giuruksyyaj30h5024dg4.jpg" srcset="/img/loading.gif" alt="image-20200918140906399"></p><p>这个对象的<code>memoizedState</code>属性就是用来存储组件上一次更新后的 <code>state</code>,<code>next</code>毫无疑问是指向下一个hook对象。在组件更新的过程中，hooks函数执行的顺序是不变的，就可以根据这个链表拿到当前hooks对应的<code>Hook</code>对象，函数式组件就是这样拥有了state的能力。当前，具体的实现肯定比这三言两语复杂很多。</p><p>所以，知道为什么不能将hooks写到if else语句中了把？因为这样可能会导致顺序错乱，导致当前hooks拿到的不是自己对应的Hook对象。</p><p><code>useEffect</code> 接收了两个参数，一个回调函数和一个数组。数组里面就是 <code>useEffect</code> 的依赖，当为 [] 的时候，回调函数只会在组件第一次渲染的时候执行一次。如果有依赖其他项，react 会判断其依赖是否改变，如果改变了就会执行回调函数。说回最初的场景：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">1</span>);    useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(count)        &#125;, <span class="hljs-number">1000</span>)    &#125;, [])    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span>&#123; setCount(<span class="hljs-number">2</span>) &#125;&#125;</code></pre><p>好，开动脑袋开始想象起来，组件第一次渲染执行 <code>App()</code>，执行 <code>useState</code> 设置了初始状态为1，所以此时的 <code>count</code> 为1。然后执行了 <code>useEffect</code>，回调函数执行，设置了一个定时器每隔 1s 打印一次 <code>count</code>。</p><p>接着想象如果 <code>click</code> 函数被触发了，调用 <code>setCount(2)</code> 肯定会触发react的更新，更新到当前组件的时候也是执行 <code>App()</code>，之前说的链表已经形成了哈，此时 <code>useState</code> 将 <code>Hook</code> 对象 上保存的状态置为2， 那么此时 <code>count</code> 也为2了。然后在执行 <code>useEffect</code> 由于依赖数组是一个空的数组，所以此时回调并不会被执行。</p><p>ok，这次更新的过程中根本就没有涉及到这个定时器，这个定时器还在坚持的，默默的，每隔1s打印一次 <code>count</code>。 注意这里打印的 <code>count</code> ，是组件第一次渲染的时候 <code>App()</code> 时的 <code>count</code>， <code>count</code>的值为1，<strong>因为在定时器的回调函数里面被引用了，形成了闭包一直被保存</strong>。</p><h2 id="2-难道真的要在依赖数组里写上的值，才能拿到新鲜的值？"><a href="#2-难道真的要在依赖数组里写上的值，才能拿到新鲜的值？" class="headerlink" title="2 难道真的要在依赖数组里写上的值，才能拿到新鲜的值？"></a>2 难道真的要在依赖数组里写上的值，才能拿到新鲜的值？</h2><p>仿佛都习惯性都去认为，只有在依赖数组里写上我们所需要的值，才能在更新的过程中拿到最新鲜的值。那么看一下这个场景：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo1</span> /&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo1</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> [num1, setNum1] = useState(<span class="hljs-number">1</span>)  <span class="hljs-keyword">const</span> [num2, setNum2] = useState(<span class="hljs-number">10</span>)  <span class="hljs-keyword">const</span> text = useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`num1: <span class="hljs-subst">$&#123;num1&#125;</span> | num2:<span class="hljs-subst">$&#123;num2&#125;</span>`</span>  &#125;, [num2])  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handClick</span>(<span class="hljs-params"></span>)</span>&#123;    setNum1(<span class="hljs-number">2</span>)    setNum2(<span class="hljs-number">20</span>)  &#125;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &#123;text&#125;      &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handClick&#125;</span>&gt;</span>click!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;  )&#125;</code></pre><p><code>text</code> 是一个 <code>useMemo</code> ，它的依赖数组里面只有num2，没有num1，却同时使用了这两个state。当点击button 的时候，num1和num2的值都改变了。那么，只写明了依赖num2的 text 中能否拿到 num1 最新鲜的值呢？</p><p>如果你装了 <code>react</code> 的 eslint 插件，这里也许会提示你错误，因为在text中你使用了 num1 却没有在依赖数组中添加它。 但是执行这段代码会发现，是可以正常拿到num1最新鲜的值的。</p><p>如果理解了之前第一点说的“闭包陷阱”问题，肯定也能理解这个问题。</p><p>为什么呢，再说一遍，这个依赖数组存在的意义，是react为了判定，在<strong>本次更新</strong>中，是否需要执行其中的回调函数，这里依赖了的num2，而num2改变了。回调函数自然会执行， 这时形成的闭包引用的就是最新的num1和num2，所以，自然能够拿到新鲜的值。问题的关键，在于回调函数执行的时机，闭包就像是一个照相机，把回调函数执行的那个时机的那些值保存了下来。之前说的定时器的回调函数我想就像是一个从1000年前穿越到现代的人，虽然来到了现代，但是身上的血液、头发都是1000年前的。</p><h2 id="3-为什么使用useRef能够每次拿到新鲜的值？"><a href="#3-为什么使用useRef能够每次拿到新鲜的值？" class="headerlink" title="3 为什么使用useRef能够每次拿到新鲜的值？"></a>3 为什么使用useRef能够每次拿到新鲜的值？</h2><p>大白话说：因为初始化的 <code>useRef</code> 执行之后，返回的都是同一个对象。写到这里宝宝又不禁回忆起刚学js那会儿，捧着红宝书啃时候的场景了：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> A = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'evanchen'</span>&#125;<span class="hljs-keyword">var</span> B = AB.name = <span class="hljs-string">'baobao'</span><span class="hljs-built_in">console</span>.log(A.name) <span class="hljs-comment">// baobao</span></code></pre><p>对，这就是这个场景成立的最根本原因。</p><p>也就是说，在组件每一次渲染的过程中。 比如 <code>ref = useRef()</code> 所返回的都是同一个对象，每次组件更新所生成的<code>ref</code>指向的都是同一片内存空间， 那么当然能够每次都拿到最新鲜的值了。犬夜叉看过把？一口古井连接了现代世界与500年前的战国时代，这个同一个对象也将这些个被保存于不同闭包时机的变量了联系了起来。</p><p>使用一个例子或许好理解一点：</p><pre><code class="hljs js">   <span class="hljs-comment">/* 将这些相关的变量写在函数外 以模拟react hooks对应的对象 */</span><span class="hljs-keyword">let</span> isC = <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> isInit = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟组件第一次加载</span><span class="hljs-keyword">let</span> ref = &#123;current: <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEffect</span>(<span class="hljs-params">cb</span>)</span>&#123;<span class="hljs-comment">// 这里用来模拟 useEffect 依赖为 [] 的时候只执行一次。</span><span class="hljs-keyword">if</span> (isC) <span class="hljs-keyword">return</span>isC = <span class="hljs-literal">true</span>cb()&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useRef</span>(<span class="hljs-params">value</span>)</span>&#123;<span class="hljs-comment">// 组件是第一次加载的话设置值 否则直接返回对象</span><span class="hljs-keyword">if</span> ( isInit ) &#123;ref.current = valueisInit = <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> ref&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">let</span> ref_ = useRef(<span class="hljs-number">1</span>)ref_.current++useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(ref.current) <span class="hljs-comment">// 3</span>&#125;, <span class="hljs-number">2000</span>)&#125;)&#125;<span class="hljs-comment">// 连续执行两次 第一次组件加载 第二次组件更新</span>App()App()</code></pre><p>所以，提出一个合理的设想。只要我们能保证每次组件更新的时候，<code>useState</code> 返回的是同一个对象的话？我们也能绕开闭包陷阱这个情景吗？ 试一下吧。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// return &lt;Demo1 /&gt;</span>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo2</span> /&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo2</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> [obj, setObj] = useState(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'evanchen'</span>&#125;)  useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;      <span class="hljs-built_in">console</span>.log(obj)    &#125;, <span class="hljs-number">2000</span>)  &#125;, [])    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handClick</span>(<span class="hljs-params"></span>)</span>&#123;    setObj(<span class="hljs-function">(<span class="hljs-params">prevState</span>)=&gt;</span> &#123;      <span class="hljs-keyword">var</span> nowObj = <span class="hljs-built_in">Object</span>.assign(prevState, &#123;        name: <span class="hljs-string">'baobao'</span>,        age: <span class="hljs-number">24</span>      &#125;)      <span class="hljs-built_in">console</span>.log(nowObj == prevState)      <span class="hljs-keyword">return</span> nowObj    &#125;)  &#125;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;div&gt;        &lt;span&gt;name: &#123;obj.name&#125; | age: &#123;obj.age&#125;&lt;<span class="hljs-regexp">/span&gt;</span><span class="hljs-regexp">        &lt;div&gt;&lt;button onClick=&#123;handClick&#125;&gt;click!&lt;/</span>button&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      &lt;/</span>div&gt;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">  )</span><span class="hljs-regexp">&#125;</span></code></pre><p>简单说下这段代码，在执行 <code>setObj</code> 的时候，传入的是一个函数。这种用法就不用我多说了把？然后 <code>Object.assign</code> 返回的就是传入的第一个对象。总儿言之，就是在设置的时候返回了同一个对象。</p><p>执行这段代码发现，确实点击button后，定时器打印的值也变成了：</p><pre><code class="hljs js">&#123;    name: <span class="hljs-string">'baobao'</span>,    age: <span class="hljs-number">24</span> &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中的type和interface区别</title>
    <link href="/2019-09-03-TypeScript%E4%B8%AD%E7%9A%84type%E5%92%8Cinterface%E5%8C%BA%E5%88%AB/"/>
    <url>/2019-09-03-TypeScript%E4%B8%AD%E7%9A%84type%E5%92%8Cinterface%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="接口VS类型"><a href="#接口VS类型" class="headerlink" title="接口VS类型"></a>接口VS类型</h1><p>大家使用typescript总会使用到接口和类型，<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank" rel="noopener">官方规范</a>稍微说了下两者的区别</p><blockquote><ul><li>可以在extend或Implements子句中命名接口，但是不能为对象类型文字提供类型别名。</li><li>一个接口可以具有多个合并的声明，但是对象类型文字的类型别名不能<br>。</li></ul></blockquote><p>明人不说暗话，直接上区别。</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><h3 id="都可以描述一个对象或函数"><a href="#都可以描述一个对象或函数" class="headerlink" title="都可以描述一个对象或函数"></a>都可以描述一个对象或函数</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> User &#123;  name: <span class="hljs-built_in">string</span>  age: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">interface</span> SetUser &#123;  (name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;&#125;</code></pre><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> User = &#123;  name: <span class="hljs-built_in">string</span>  age: <span class="hljs-built_in">number</span>&#125;;<span class="hljs-keyword">type</span> SetUser = (name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;</code></pre><h3 id="扩展（extends）与交叉类型（Intersection-Types）"><a href="#扩展（extends）与交叉类型（Intersection-Types）" class="headerlink" title="扩展（extends）与交叉类型（Intersection Types）"></a>扩展（extends）与交叉类型（Intersection Types）</h3><p>interface可以扩展，但类型是可以扩展和实现的，<strong>但是类型缺可以通过交叉类型实现interface的extend行为</strong>，并且彼此无关相互独立的，则interface可以扩展类型，类型也可以与接口类型交叉。</p><p><strong>虽然效果差不多，但是某些语法不同</strong>。</p><h4 id="接口扩展接口"><a href="#接口扩展接口" class="headerlink" title="接口扩展接口"></a>接口扩展接口</h4><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Name &#123;   name: <span class="hljs-built_in">string</span>; &#125;<span class="hljs-keyword">interface</span> User <span class="hljs-keyword">extends</span> Name &#123;   age: <span class="hljs-built_in">number</span>; &#125;</code></pre><h4 id="类型与类型交叉"><a href="#类型与类型交叉" class="headerlink" title="类型与类型交叉"></a>类型与类型交叉</h4><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Name = &#123;   name: <span class="hljs-built_in">string</span>; &#125;<span class="hljs-keyword">type</span> User = Name &amp; &#123; age: <span class="hljs-built_in">number</span>  &#125;;</code></pre><h4 id="接口扩展类型"><a href="#接口扩展类型" class="headerlink" title="接口扩展类型"></a>接口扩展类型</h4><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Name = &#123;   name: <span class="hljs-built_in">string</span>; &#125;<span class="hljs-keyword">interface</span> User <span class="hljs-keyword">extends</span> Name &#123;   age: <span class="hljs-built_in">number</span>; &#125;</code></pre><h4 id="类型与接口交叉"><a href="#类型与接口交叉" class="headerlink" title="类型与接口交叉"></a>类型与接口交叉</h4><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Name &#123;   name: <span class="hljs-built_in">string</span>; &#125;<span class="hljs-keyword">type</span> User = Name &amp; &#123;   age: <span class="hljs-built_in">number</span>; &#125;</code></pre><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="类型可以而interface不行"><a href="#类型可以而interface不行" class="headerlink" title="类型可以而interface不行"></a>类型可以而interface不行</h3><ul><li>类型可以声明基本类型别名，联合类型，元组等类型</li></ul><pre><code class="hljs typescript"><span class="hljs-comment">//基本类型别名</span><span class="hljs-keyword">type</span>  Name  =  <span class="hljs-built_in">string</span><span class="hljs-comment">//联合类型</span>接口 Dog  &#123;     wong （）; &#125; 接口 Cat  &#123;     miao （）; &#125;键入 宠物 =  狗 | 猫<span class="hljs-comment">//具体定义每个每个位置的类型</span><span class="hljs-keyword">type</span>  PetList  =  [ Dog ， Pet ]</code></pre><ul><li>type语句中还可以使用typeof获取实例的类型进行赋值</li></ul><pre><code class="hljs typescript"><span class="hljs-comment">// 当你想获取一个变量的类型时，使用 typeof</span><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);<span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> div</code></pre><ul><li>其他骚操作</li></ul><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> StringOrNumber = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;  <span class="hljs-keyword">type</span> Text = <span class="hljs-built_in">string</span> | &#123; text: <span class="hljs-built_in">string</span> &#125;;  <span class="hljs-keyword">type</span> NameLookup = Dictionary&lt;<span class="hljs-built_in">string</span>, Person&gt;;  <span class="hljs-keyword">type</span> Callback&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params">data: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>;  <span class="hljs-keyword">type</span> Pair&lt;T&gt; = [T, T];  <span class="hljs-keyword">type</span> Coordinates = Pair&lt;<span class="hljs-built_in">number</span>&gt;;  <span class="hljs-keyword">type</span> Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</code></pre><h3 id="接口可以而type不行"><a href="#接口可以而type不行" class="headerlink" title="接口可以而type不行"></a>接口可以而type不行</h3><p>接口能够声明合并</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> User &#123;  name: <span class="hljs-built_in">string</span>  age: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">interface</span> User &#123;  sex: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">User 接口为 &#123;</span><span class="hljs-comment">  name: string</span><span class="hljs-comment">  age: number</span><span class="hljs-comment">  sex: string </span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至少，如果不清楚什么时候用interface / type，能用interface实现，就用interface，如果不能就用type。其他更多详情参见<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank" rel="noopener">官方规范文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础之变量和常量</title>
    <link href="/2019-08-07-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
    <url>/2019-08-07-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><hr><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><pre><code class="hljs go"><span class="hljs-keyword">break</span>        <span class="hljs-keyword">default</span>      <span class="hljs-function"><span class="hljs-keyword">func</span>         <span class="hljs-title">interface</span>    <span class="hljs-title">select</span></span><span class="hljs-keyword">case</span>         <span class="hljs-keyword">defer</span>        <span class="hljs-keyword">go</span>           <span class="hljs-keyword">map</span>          <span class="hljs-keyword">struct</span><span class="hljs-keyword">chan</span>         <span class="hljs-keyword">else</span>         <span class="hljs-keyword">goto</span>         <span class="hljs-keyword">package</span>      <span class="hljs-keyword">switch</span><span class="hljs-keyword">const</span>        <span class="hljs-keyword">fallthrough</span>  <span class="hljs-keyword">if</span>           <span class="hljs-keyword">range</span>        <span class="hljs-keyword">type</span><span class="hljs-keyword">continue</span>     <span class="hljs-keyword">for</span>          <span class="hljs-keyword">import</span>       <span class="hljs-keyword">return</span>       <span class="hljs-keyword">var</span></code></pre><p>此外，Go语言中还有37个保留字。</p><pre><code class="hljs go">Constants:    <span class="hljs-literal">true</span>  <span class="hljs-literal">false</span>  <span class="hljs-literal">iota</span>  <span class="hljs-literal">nil</span>    Types:    <span class="hljs-keyword">int</span>  <span class="hljs-keyword">int8</span>  <span class="hljs-keyword">int16</span>  <span class="hljs-keyword">int32</span>  <span class="hljs-keyword">int64</span>                <span class="hljs-keyword">uint</span>  <span class="hljs-keyword">uint8</span>  <span class="hljs-keyword">uint16</span>  <span class="hljs-keyword">uint32</span>  <span class="hljs-keyword">uint64</span>  <span class="hljs-keyword">uintptr</span>              <span class="hljs-keyword">float32</span>  <span class="hljs-keyword">float64</span>  <span class="hljs-keyword">complex128</span>  <span class="hljs-keyword">complex64</span>              <span class="hljs-keyword">bool</span>  <span class="hljs-keyword">byte</span>  <span class="hljs-keyword">rune</span>  <span class="hljs-keyword">string</span>  errorFunctions:   <span class="hljs-built_in">make</span>  <span class="hljs-built_in">len</span>  <span class="hljs-built_in">cap</span>  <span class="hljs-built_in">new</span>  <span class="hljs-built_in">append</span>  <span class="hljs-built_in">copy</span>  <span class="hljs-built_in">close</span>  <span class="hljs-built_in">delete</span>             <span class="hljs-built_in">complex</span>  <span class="hljs-built_in">real</span>  <span class="hljs-built_in">imag</span>             <span class="hljs-built_in">panic</span>  <span class="hljs-built_in">recover</span></code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名 变量类型</code></pre><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> isOk <span class="hljs-keyword">bool</span></code></pre><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (    a <span class="hljs-keyword">string</span>    b <span class="hljs-keyword">int</span>    c <span class="hljs-keyword">bool</span>    d <span class="hljs-keyword">float32</span>)</code></pre><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名 类型 = 表达式</code></pre><p>举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">"Q1mi"</span><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span></code></pre><p>或者一次初始化多个变量</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> name, age = <span class="hljs-string">"Q1mi"</span>, <span class="hljs-number">20</span></code></pre><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"Q1mi"</span><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span></code></pre><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-comment">// 全局变量m</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">100</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">10</span>m := <span class="hljs-number">200</span> <span class="hljs-comment">// 此处声明局部变量m</span>fmt.Println(m, n)&#125;</code></pre><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>, <span class="hljs-string">"Q1mi"</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;x, _ := foo()_, y := foo()fmt.Println(<span class="hljs-string">"x="</span>, x)fmt.Println(<span class="hljs-string">"y="</span>, y)&#125;</code></pre><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code>不能使用在函数外。</li><li><code>_</code>多用于占位，表示忽略值。</li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span></code></pre><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    pi = <span class="hljs-number">3.1415</span>    e = <span class="hljs-number">2.7182</span>)</code></pre><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    n1 = <span class="hljs-number">100</span>    n2    n3)</code></pre><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span>n2        <span class="hljs-comment">//1</span>n3        <span class="hljs-comment">//2</span>n4        <span class="hljs-comment">//3</span>)</code></pre><h3 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的<code>iota</code>示例:</h3><p>使用<code>_</code>跳过某些值</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span>n2        <span class="hljs-comment">//1</span>_n4        <span class="hljs-comment">//3</span>)</code></pre><p><code>iota</code>声明中间插队</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span>n2 = <span class="hljs-number">100</span>  <span class="hljs-comment">//100</span>n3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span>n4        <span class="hljs-comment">//3</span>)<span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span></code></pre><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (_  = <span class="hljs-literal">iota</span>KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)MB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)GB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)TB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)PB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>))</code></pre><p>多个<code>iota</code>定义在一行</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//1,2</span>c, d                      <span class="hljs-comment">//2,3</span>e, f                      <span class="hljs-comment">//3,4</span>)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域那点事</title>
    <link href="/2019-07-13-%E8%B7%A8%E5%9F%9F%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <url>/2019-07-13-%E8%B7%A8%E5%9F%9F%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信每个前端对于跨域这两个字都不会陌生，在实际项目中应用也很多，但跨域方法的多种多样让人目不暇接，前段时间公司同事出现了跨域问题，又一时找不到问题所在，所以在此总结下跨域知识，一篇由浅入深的万字Web基操文</p><p>其实很早就开始写了，只不过刚开始写的时候理解不够深刻，后来慢慢就写其他觉得较高大尚较内涵的了，然后就又是觉得不够完美不够深刻又写一半，就此陷入强迫症患者明知不可为而为的死循环，SO，产出少，周期长（不过大家能看到的文章都是准备良久又反复斟酌后自认为还不错的）。。。</p><p>总之又是一篇由于各种原因半途而废的积压文，这里终于收尾了，长出一口气，哎，还是太年轻，吐槽结束，进入正文</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>简单来说跨域是指一个域下的文档或脚本想要去去请求另一个域下的资源</p><p>其实一些像A链接、重定向、表单提交的资源跳转，像 <code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;</code> 等dom标签，还有样式中 <code>background:url()、@font-face()</code> 等嵌入的文件外链，又比如一些像  js 发起的ajax请求、dom 和 js 对象的跨域操作等等都是跨域</p><p>我们通常所说的跨域，大多是由浏览器同源策略限制引起的一类请求场景，这里你可能注意到了同源策略，那么浏览器的同源策略是什么呢？</p><h2 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h2><p>同源策略/SOP（Same origin policy）是一种约定，由 <code>Netscape</code> 公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_request_forgery_CSRF" target="_blank" rel="noopener">XSS、CSFR</a> 等攻击</p><p>同源同源，什么是源呢？源指的是 <code>协议、域名、端口</code> ，那么同源即三者相同，即便是不同的域名指向同一个ip地址，也不同源</p><p>我们来看一个域名组成，我们以 <code>http://www.hahaha.com/abc/a.js</code> 为例</p><ul><li>http://            –&gt;    协议</li><li>www              –&gt;    子域名</li><li>hahaha.com –&gt;    主域名</li><li>80                   –&gt;     端口（<code>http://</code> 默认端口是80）</li><li>abc/a.js         –&gt;     请求资源路径</li></ul><p>那么我们以这个域名的源为例，来与下面这些做下对比</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.hahaha.com/abc/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>http://www.hahaha.com/def/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>https://www.hahaha.com/abc/a.js</code></td><td>不同源</td><td>协议不同</td></tr><tr><td><code>http://www.hahaha.com:8081/abc/a.js</code></td><td>不同源</td><td>端口不同</td></tr><tr><td><code>http://aaa.hahaha.com/abc/a.js</code></td><td>不同源</td><td>主机不同</td></tr></tbody></table><p>而在不同源的情况下，同源策略限制了我们</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容无法读取</li><li>DOM 节点和 Js对象无法获得</li><li>AJAX 请求发送后，结果被浏览器拦截（注意是 <strong>请求发送出去了，也拿到结果了，只是被浏览器截胡了</strong>）</li></ul><p>到了这里，相信你对跨域已经有所了解了，那么我们如何有效的规避跨域呢，应该说如何解决跨域问题，因为我们在开发过程中免不了要跨域，针对不同的类型，解决跨域的方式也有很多</p><h2 id="不同类型的跨域解决方案"><a href="#不同类型的跨域解决方案" class="headerlink" title="不同类型的跨域解决方案"></a>不同类型的跨域解决方案</h2><h3 id="No-1-document-domain-iframe跨域"><a href="#No-1-document-domain-iframe跨域" class="headerlink" title="No.1 document.domain+iframe跨域"></a>No.1 document.domain+iframe跨域</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>document.domain</code> 的方式实现跨域，适用场景仅在 <strong>主域名相同，子级域名不同</strong> 的情况下</p><p>例如，下面这两个页面</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//aaa.hahaha.com/a.html</span><span class="hljs-symbol">http:</span><span class="hljs-comment">//bbb.hahaha.com/b.html</span>复制代码</code></pre><p>那么它可以做到什么呢</p><ul><li>两个页面设置相同的 <code>document.domain</code> ，共享Cookie</li><li>两个页面设置相同的 <code>document.domain</code> ，通过 <code>iframe</code> 实现两个页面的数据互通</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h5><p>首先，两个页面都设置相同的 <code>document.domain</code></p><pre><code class="hljs js"><span class="hljs-built_in">document</span>.domain = <span class="hljs-string">'hahaha.com'</span>;</code></pre><p>页面 a 通过脚本设置一个 Cookie</p><pre><code class="hljs js"><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">"test=a"</span>;</code></pre><p>网页 b 读这个 Cookie</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> cookieA = <span class="hljs-built_in">document</span>.cookie;<span class="hljs-built_in">console</span>.log(cookieA)</code></pre><p>服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.hahaha.com</code></p><pre><code class="hljs js"><span class="hljs-built_in">Set</span>-Cookie: key=value; domain=.hahaha.com; path=<span class="hljs-regexp">/</span></code></pre><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p><h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><pre><code class="hljs html"><span class="hljs-comment">&lt;!--a页面--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://bbb.hahaha.com/b.html"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"load()"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">'hahaha.com'</span>;</span><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-string">"this is a"</span>;</span>  <span class="actionscript">  <span class="hljs-comment">// 获取b页面数据</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">    <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"frame"</span>)</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(frame.contentWindow.b) <span class="hljs-comment">// this is b</span></span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--b页面--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">'hahaha.com'</span>;</span><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-string">"this is b"</span></span>  <span class="actionscript">  <span class="hljs-comment">// 获取a页面数据</span></span><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.parent.a); <span class="hljs-comment">// this is a</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li>首先，仅在主域名相同，子级域名不同的情况下</li><li>只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 数据无法通过这种方法共享</li></ul><h3 id="No-2-location-hash-iframe跨域"><a href="#No-2-location-hash-iframe跨域" class="headerlink" title="No.2 location.hash + iframe跨域"></a>No.2 location.hash + iframe跨域</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>两个页面不同源，是无法拿到对方DOM的，典型的例子就是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口是无法通信的</p><p>比如，不同源的页面a和页面b，如果我们直接获取对方数据</p><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha1.com/b.html"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"load()"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-string">"this is a"</span></span>  <span class="actionscript">  <span class="hljs-comment">// 获取b页面数据</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"frame"</span>).contentWindow.b) </span><span class="actionscript">    <span class="hljs-comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--b--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-string">"this is b"</span></span>  <span class="actionscript">  <span class="hljs-comment">// 获取a页面数据</span></span><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.parent.a); <span class="hljs-comment">// 报错</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>显而易见，都是获取不到的，因为都跨域了，上面我们讲到的 <code>document.domain</code>，只能在同主域名的情况下使用才能规避同源政策，而在主域名不相同的情况下是没有办法做到的</p><p>我们来了解另一种办法 <code>window.location.hash</code>，它拿到的是 URL 的<code>#</code>号后面的部分，它叫片段标识符（fragment identifier）</p><p>比如 <code>http://hahaha.com/a.html#fragment</code> 的 <code>#fragment</code> ，如果只是改变片段标识符，页面是不会重新刷新的，就像大名鼎鼎的Vue中的hash路由就是用的这种方式</p><p>通过 <code>location.hash</code> + <code>iframe</code> 我们可以做到在不同主域下也可以拿到对方的数据</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>首先，我们要实现页面a和页面b的跨域相互通信，因为不同域所以利用 <code>iframe</code> 加上 <code>location.hash</code> 传值，但是这个传值是单向的，只能由一方向另一方传值，不同域时子页面并不能获取到父页面，也就不能相互通信，所以我们需要一个中间人页面c来帮忙</p><p>不同域之间利用 <code>iframe</code> 的<code>location.hash</code> 传值，相同域之间直接 JS 访问来通信</p><p>那么我们的逻辑就变成了下面这样</p><blockquote><p>a 与 b 不同域只能通过hash值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过parent.parent 访问 a 页面所有对象</p></blockquote><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--a中通过iframe引入了b--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha1.com/b.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'frame'</span>);</span><span class="actionscript">  <span class="hljs-comment">// 向b传hash值</span></span><span class="actionscript">  frame.src = frame.src + <span class="hljs-string">'#a=我是a'</span>;</span><span class="actionscript">  <span class="hljs-comment">// 给同域c使用的回调方法</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span><span class="hljs-params">(data)</span> </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// 打印 我是a+b</span></span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!--b中通过iframe引入了中间人c--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha0.com/c.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'frame'</span>);</span><span class="actionscript">  <span class="hljs-comment">// 监听a传来的hash值，传给c.html</span></span><span class="javascript">  <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">    frame.src = frame.src + location.hash + <span class="hljs-string">'+b'</span>;</span>  &#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面c：<code>http://www.hahaha0.com/c.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">// 监听 b 的hash值变化</span></span><span class="javascript">  <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">    <span class="hljs-comment">// c调用父亲的父亲，来操作同域a的js回调，将结果传回</span></span><span class="javascript">    <span class="hljs-built_in">window</span>.parent.parent.cb(location.hash.replace(<span class="hljs-string">'#a='</span>, <span class="hljs-string">''</span>));</span>  &#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="No-3-window-name-iframe跨域"><a href="#No-3-window-name-iframe跨域" class="headerlink" title="No.3 window.name + iframe跨域"></a>No.3 window.name + iframe跨域</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>window</code> 对象有一个 <code>name</code> 属性，该属性有一个特征，即在一个窗口的生命周期内，窗口载入所有的页面都是共享一个 <code>window.name</code> 的，每一个页面对 <code>window.name</code> 都有读写的权限</p><p><code>window.name</code> 是持久的存在于一个窗口载入的所有页面中的，并不会因为新的页面的载入而被重置，比如下例</p><p>页面a</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">'我是a'</span>;</span><span class="actionscript">  setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><span class="javascript">    <span class="hljs-built_in">window</span>.location = <span class="hljs-string">'b.html'</span>; <span class="hljs-comment">// 两秒后把一个新页面b.html载入到当前的window中</span></span>  &#125;,2000) <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name); <span class="hljs-comment">// 我是a</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>通过上面这个例子，我们可以很直观的看到，a 页面载入2s后，跳转到 b 页面，b 会在控制台输出 <code>我是a</code></p><p>不过 <code>window.name</code> 的值只能是字符串的形式，最大允许2M左右，具体取决于不同的浏览器，但是一般是够用了</p><p>那么我们就可以利用它这一特性来实现跨域，看标题就知道是使用 <code>window.name</code> 和 <code>iframe</code> ，那么你能想到要如何投机取巧，哦不，是巧妙的规避跨域而不留痕迹吗？</p><p>经历过上文的摧残我们知道，不同域情况下的 a 页面和 b 页面，使用 <code>iframe</code> 嵌入一个页面，数据也是互通不了的，因为会跨域，这里我们要使用 <code>window.name</code> + <code>iframe</code> 来实现跨域数据互通，显然我们不能直接在 a 页面中通过改变 <code>window.location</code> 来载入b 页面，因为我们现在需要实现的是 a 页面不跳转，但是也能够获取到 b 中的数据</p><blockquote><p>究竟要怎么实现呢？其实还是要靠一个中间人页面 c</p><p>首先中间人 c 要和 a 是同域</p><p>a 页面中通过 <code>iframe</code> 加载了 b ，在 b 页面中把数据留在了当前 <code>iframe</code> 窗口的  <code>window.name</code> 属性里</p><p>这个时候 a 是读取不了 <code>iframe</code> 的，因为不同域，但是我们可以在 a 中动态的把 <code>iframe</code> 的 <code>src</code> 改为 c</p><p>中间人 c 什么都不用写，因为它直接继承了 b 留下的 <code>window.name</code></p><p>因为c 和 a因为是同域，所以 a 可以正常拿到子页面 c 中的 <code>window.name</code> 属性值</p><p>不得不说，这种做法还真挺让人叹为观止的，致敬前辈们</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha2.com/abc/b.html"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"load()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span><span class="actionscript">  <span class="hljs-comment">// onload事件会触发2次</span></span><span class="actionscript">  <span class="hljs-comment">// 第1次onload跨域页b成功后，留下数据window.name，后切换到同域代理页面</span></span><span class="actionscript">  <span class="hljs-comment">// 第2次onload同域页c成功后，读取同域window.name中数据</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>&#123;</span>    if(flag)&#123;<span class="actionscript">      <span class="hljs-comment">// 第1次</span></span><span class="javascript">      <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'frame'</span>)</span><span class="actionscript">      frame.src = <span class="hljs-string">'http://www.hahaha1.com/abc/c.html'</span></span><span class="actionscript">      flag = <span class="hljs-literal">false</span></span><span class="actionscript">    &#125;<span class="hljs-keyword">else</span>&#123;</span><span class="actionscript">      <span class="hljs-comment">// 第二次</span></span><span class="javascript">      <span class="hljs-built_in">console</span>.log(frame.contentWindow.name) <span class="hljs-comment">// 我是b</span></span>    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">'我是b'</span>  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="No-4-window-postMessage跨域"><a href="#No-4-window-postMessage跨域" class="headerlink" title="No.4 window.postMessage跨域"></a>No.4 window.postMessage跨域</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>我们上面说的几种窗口跨域做法是可以适用相应场景且安全可靠的，但是它们都是属于投机取巧，不对，是另辟捷径，但是<code>HTML5 XMLHttpRequest Level 2</code>中为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）</p><p>这个API为 <code>window</code> 对象新增了一个 <code>window.postMessage</code> 方法，可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</p><p>主流浏览器的兼容情况也非常可观</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggpfeqc7f4j31h20cxn1h.jpg" srcset="/img/loading.gif" alt="image-20200713163012343"></p><p>我们来看下它的使用，先来看看它怎么发送数据</p><pre><code class="hljs js">otherWindow.postMessage(message, targetOrigin, [transfer]);</code></pre><ul><li>otherWindow<ul><li>窗口的一个引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性，执行 <code>window.open</code> 返回的窗口对象，或者是命名过的或数值索引的 <code>window.frames</code></li></ul></li><li>message<ul><li>要发送到其他窗口的数据，它将会被 <a href="https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法 </a> 序列化，这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化</li></ul></li><li>targetOrigin<ul><li>通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件，指定后只有对应 <code>origin</code> 下的窗口才可以接收到消息，设置为通配符 <code>*</code> 表示可以发送到任何窗口，但通常处于安全性考虑不建议这么做，如果想要发送到与当前窗口同源的窗口，可设置为 <code>/</code></li></ul></li><li>transfer | 可选属性<ul><li>是一串和 <code>message</code> 同时传递的 <strong>Transferable</strong> 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li></ul></li></ul><p>它也可以监听 <code>message</code> 事件的发生来接收数据</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"message"</span>, receiveMessage, <span class="hljs-literal">false</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receiveMessage</span>(<span class="hljs-params">event</span>) </span>&#123;  <span class="hljs-keyword">let</span> origin= event.origin  <span class="hljs-built_in">console</span>.log(event)&#125;</code></pre><p>接下来我们实战下跨域情况下，通过 <code>window.postMessage</code> 来互通数据</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>还是以不同域的页面 a 和 b 为例子</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code>，创建跨域 <code>iframe</code> 并发送信息</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha2.com/abc/b.html"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"load()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">    <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'frame'</span>)</span><span class="actionscript">    <span class="hljs-comment">// 发送</span></span><span class="actionscript">    frame.contentWindow.postMessage(<span class="hljs-string">'哈喽，我是a'</span>, <span class="hljs-string">'http://www.hahaha2.com/abc/b.html'</span>)</span>    <span class="actionscript">    <span class="hljs-comment">// 接收</span></span><span class="javascript">    <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 你好，我是b</span></span>    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code>，接收数据并返回信息</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">// 接收</span></span><span class="javascript">  <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 哈喽，我是a</span></span><span class="actionscript">    <span class="hljs-comment">// 返回数据</span></span><span class="actionscript">    e.source.postMessage(<span class="hljs-string">'你好，我是b'</span>, e.origin)</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="No-5-JSONP跨域"><a href="#No-5-JSONP跨域" class="headerlink" title="No.5 JSONP跨域"></a>No.5 JSONP跨域</h3><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>对于 <code>JSONP</code> 这块，虽然不常用，我们好好的提一下，因为遇到过一些初学者，把 <code>AJAX</code> 和 <code>JSONP</code> 混为一谈了，提起 <code>JSONP</code> ，会说很 easy，就是在 <code>AJAX</code> 请求里设置一下字段就行了，可能你用过 <code>JQuery</code> 封装后的 <code>JSONP</code> 跨域方式，确实只是在请求里加个字段，但是，那是 JQ 封装好的一种使用方式而已，可不能被表象迷惑，你真的懂它的原理吗（JQ：我可不背锅！！！）</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><code>Ajax</code> 的原理简单来说通过浏览器的 <code>javascript</code> 对象 <code>XMLHttpRequest</code> （Ajax引擎）对象向服务器发送异步请求并接收服务器的响应数据，然后用 <code>javascript</code> 来操作 DOM 而更新页面</p><p>这其中最关键的一步就是从服务器获得请求数据，即用户的请求间接通过 <code>Ajax</code> 引擎发出而不是通过浏览器直接发出，同时 <code>Ajax</code> 引擎也接收服务器返回响应的数据，所以不会导致浏览器上的页面全部刷新</p><p>使用方式也很简单</p><pre><code class="hljs livecodeserver">一：创建XMLHttpRequest对象,也就是创建一个异步调用对象二：创建一个新的HTTP请求,并指定该HTTP请求的方法、<span class="hljs-built_in">URL</span>及验证信息三：设置响应HTTP请求状态变化的函数四：发送HTTP请求五：获取异步调用返回的数据</code></pre><h4 id="JSONP，JSON？"><a href="#JSONP，JSON？" class="headerlink" title="JSONP，JSON？"></a>JSONP，JSON？</h4><p><code>JSON（JavaScript Object Notation）</code> 大家应该是很了解，就是一种轻量级的数据交换格式，不了解的同学可以去<a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">json.org </a> 上了解下，分分钟搞定</p><p>而 <code>JSONP（JSON with Padding）</code> ，它是一个 <strong>非官方</strong> 的协议，它允许在服务器端集成 <code>Script tags</code> 返回至客户端，通过 <code>javascript callback</code> 的形式实现跨域访问，这就是简单的JSONP实现形式，这么说可能不太明白，那我们来看下它到底是怎么个原理</p><h4 id="JSONP工作原理"><a href="#JSONP工作原理" class="headerlink" title="JSONP工作原理"></a>JSONP工作原理</h4><p>先来看个小例子，还是不同域的 a 和 b 两页面</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha2.com/abc/b.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 我是b</span></span>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-string">"我是b"</span></code></pre><p>可以看到，虽然不同域，但是 a 页面中还是可以访问到并打印出了 b 页面中的变量</p><p>这个小例子我们可以很直观的看到 <code>&lt;script&gt;</code> 标签的 src 属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行它，这就是 <code>JSONP</code> 最核心的原理了，至于它如何传递数据，我们来简单实现一个</p><h4 id="JSONP的CallBack实现"><a href="#JSONP的CallBack实现" class="headerlink" title="JSONP的CallBack实现"></a>JSONP的CallBack实现</h4><p>刚才的例子说了跨域的原理，而且我们之前有讲到 <code>javascript callback</code> 的形式实现跨域访问，那我们就来修改下代码，如何实现 <code>JSONP</code> 的 <code>javascript callback</code> 的形式</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">//回调函数</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span><span class="hljs-params">(res)</span> </span>&#123;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(res.data.b) <span class="hljs-comment">// 我是b</span></span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.hahaha2.com/abc/b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-string">"我是b"</span><span class="hljs-comment">// 调用cb函数，并以json数据形式作为参数传递</span>cb(&#123;  code:<span class="hljs-number">200</span>,   msg:<span class="hljs-string">"success"</span>,  data:&#123;    b: b  &#125;&#125;)</code></pre><p>创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调，就是 <code>JSONP</code> 的简单实现模式，或者说是 <code>JSONP</code> 的原型，是不是很简单呢</p><p>将 <code>JSON</code> 数据填充进回调函数，现在懂为什么 <code>JSONP</code> 叫 <code>JSON with Padding</code> 了吧</p><p>上面这种实现很简单，通常情况下，我们希望这个 <code>script</code> 标签能够动态的调用，而不是像上面因为固定在 <code>HTML</code> 里面加载时直接执行了，很不灵活，我们可以通过 <code>javascript</code> 动态的创建 <code>script</code> 标签，这样我们就可以灵活调用远程服务了，那么我们简单改造下页面 a 如下</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span><span class="hljs-params">(res)</span> </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(res.data.b)  <span class="hljs-comment">// 我是b</span></span>  &#125;  <span class="handlebars"><span class="xml">  // 动态添加 <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> 标签方法</span></span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScriptTag</span><span class="hljs-params">(src)</span></span>&#123;</span><span class="javascript">    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>)</span><span class="actionscript">    script.setAttribute(<span class="hljs-string">"type"</span>,<span class="hljs-string">"text/javascript"</span>)</span>    script.src = src<span class="javascript">    <span class="hljs-built_in">document</span>.body.appendChild(script)</span>  &#125;<span class="javascript">  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="actionscript">    addScriptTag(<span class="hljs-string">"http://www.hahaha2.com/abc/b.js"</span>)</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>如上所示，只是些基础操作，就不解释了，现在我们就可以优雅的控制执行了，再想调用一个远程服务的话，只要添加 <code>addScriptTag</code> 方法，传入远程服务的 src 值就可以</p><p>接下来我们就可以愉快的进行一次真正意义上的 <code>JSONP</code> 服务调取了</p><p>我们使用 <code>jsonplaceholder</code> 的 <code>todos</code> 接口作为示例，接口地址如下</p><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//jsonplaceholder.typicode.com/todos?callback=?</span></code></pre><p><code>callback=?</code> 这个拼在接口后面表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的 <code>JSON</code> 数据传入这个方法完成回调，我们的回调函数名字叫 <code>cb</code>，那么完整的接口地址就如下</p><pre><code class="hljs vim">http<span class="hljs-variable">s:</span>//jsonplaceholder.typicode.<span class="hljs-keyword">com</span>/todos?callback=<span class="hljs-keyword">cb</span></code></pre><p>那么话不多说，我们来试下</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span><span class="hljs-params">(res)</span> </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(res)</span>  &#125;  <span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScriptTag</span><span class="hljs-params">(src)</span></span>&#123;</span><span class="javascript">    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>)</span><span class="actionscript">    script.setAttribute(<span class="hljs-string">"type"</span>,<span class="hljs-string">"text/javascript"</span>)</span>    script.src = src<span class="javascript">    <span class="hljs-built_in">document</span>.body.appendChild(script)</span>  &#125;<span class="javascript">  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="actionscript">    addScriptTag(<span class="hljs-string">"https://jsonplaceholder.typicode.com/todos?callback=cb"</span>)</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>可以看到，页面在加载完成后，输出了接口返回的数据，这个时候我们再来看 JQ 中的 JSONP 实现</p><h4 id="JSONP的JQuery实现"><a href="#JSONP的JQuery实现" class="headerlink" title="JSONP的JQuery实现"></a>JSONP的JQuery实现</h4><p>还是用上面的接口，我们来看 JQ 怎么拿数据</p><pre><code class="hljs js">$.ajax(&#123;  url:<span class="hljs-string">"https://jsonplaceholder.typicode.com/todos?callback=?"</span>,     dataType:<span class="hljs-string">"jsonp"</span>,  jsonpCallback:<span class="hljs-string">"cb"</span>,  success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(res)  &#125;&#125;);</code></pre><p>可以看到，为了让 JQ 按照 <code>JSONP</code> 的方式访问，<code>dataType</code> 字段设置为 <code>jsonp</code> ， <code>jsonpCallback</code> 属性的作用就是自定义我们的回调方法名，其实内部和我们上面写的差不多</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a>JSONP和AJAX对比</h4><ul><li>调用方式上<ul><li><code>AJAX</code> 和 <code>JSONP</code> 很像，都是请求url，然后把服务器返回的数据进行处理</li><li>所以类 <code>JQuery</code> 的库只是把 <code>JSONP</code> 作为 <code>AJAX</code> 请求的一种形式进行封装，不要搞混</li></ul></li><li>核心原理上<ul><li><code>AJAX</code> 的核心是通过 <code>xmlHttpRequest</code> 获取非本页内容</li><li><code>JSONP</code>的核心是动态添加 <code>script</code> 标签调用服务器提供的 JS 脚本，后缀 <code>.json</code></li></ul></li><li>两者区别上，<ul><li><code>AJAX</code> 不同域会报跨域错误，不过也可以通过服务端代理、<code>CORS</code> 等方式跨域，而 <code>JSONP</code> 没有这个限制，同域不同域都可以</li><li><code>JSONP</code> 是一种方式或者说非强制性的协议，<code>AJAX</code> 也不一定非要用 <code>json</code> 格式来传递数据 </li><li><code>JSONP</code> 只支持 <code>GET</code> 请求，<code>AJAX</code> 支持 <code>GET</code> 和 <code>POST</code></li></ul></li></ul><p>最后，JSONP是很老的一种跨域方式了，现在基本没什么人用，所以，我们了解懂它即可</p><p>一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了</p><h3 id="No-6-CORS跨域资源共享"><a href="#No-6-CORS跨域资源共享" class="headerlink" title="No.6 CORS跨域资源共享"></a>No.6 CORS跨域资源共享</h3><h4 id="什么是CORS？"><a href="#什么是CORS？" class="headerlink" title="什么是CORS？"></a>什么是CORS？</h4><p>在出现 <code>CORS</code> 之前，我们都是使用 <code>JSONP</code> 的方式实现跨域，但是这种方式仅限于 <code>GET</code> 请求，而 <code>CORS</code> 的出现，为我们很好的解决了这个问题，这也是它成为一个趋势的原因</p><pre><code class="hljs routeros">CORS` 是一个W3C标准，全称是 `跨域资源共享（Cross-origin<span class="hljs-built_in"> resource </span>sharing）</code></pre><p>它允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 <code>AJAX</code> 只能同源使用的限制</p><p><code>CORS</code> 需要浏览器和服务器同时支持，目前基本所有浏览器都支持该功能，IE浏览器不低于 IE10 即可</p><p>整个 <code>CORS</code> 通信过程，都是浏览器自动完成，是不需要用户参与的，对于我们开发者来说，<code>CORS</code> 通信与同源的 <code>AJAX</code> 通信没有差别，代码完全一样，浏览器一旦发现 <code>AJAX</code> 请求跨源，就会自动添加一些附加的头信息，有的时候还会多出一次附加的请求，但这个过程中用户是无感的</p><p>因此，实现 <code>CORS</code> 通信的关键是服务器，只要服务器设置了允许的 <code>CORS</code> 接口，就可以进行跨源通信，要了解怎么实现 <code>CORS</code> 跨域通信，我们还要先了解浏览器对每个请求都做了什么</p><p>浏览器会将 <code>CORS</code> 请求分成两类，简单请求（simple request）和非简单请求（not-so-simple request），浏览器对这两种请求的处理，是不一样的</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>什么是简单请求，其实很好理解记住两条就好了</p><ul><li>请求方法是 <code>HEAD、GET、POST</code> 三种方法之一</li><li>HTTP的头信息不超出以下几种字段<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li></ul></li></ul><p>只要同时满足这两个条件，那么这个请求就是一个简单请求</p><p>对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 <code>Origin</code> 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>知道了简单请求的定义，非简单请求就比较简单了，因为只要不是简单请求，它就是非简单请求</p><p>浏览器应对非简单请求，会在正式通信之前，做一次查询请求，叫预检请求（preflight），也叫 <code>OPTIONS</code> 请求，因为它使用的请求方式是 <code>OPTIONS</code> ，这个请求是用来询问的</p><p>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就会报跨域错误</p><p>在这个预检请求里，头信息除了有表明来源的 <code>Origin</code> 字段外，还会有一个 <code>Access-Control-Request-Method</code> 字段和 <code>Access-Control-Request-Headers</code> 字段，它们分别表明了该浏览器 <code>CORS</code> 请求用到的 <code>HTTP</code> 请求方法和指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段，如果你看的云里雾里，不要着急，我们看个例子</p><p>如下为一个 AJAX 请求示例</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> url = <span class="hljs-string">'http://www.hahaha.com/abc'</span><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()xhr.open(<span class="hljs-string">'POST'</span>, url, <span class="hljs-literal">true</span>)xhr.setRequestHeader(<span class="hljs-string">'X-Token'</span>, <span class="hljs-string">'YGJHJHGJAHSGJDHGSJGJHDGSJHS'</span>)xhr.setRequestHeader(<span class="hljs-string">'X-Test'</span>, <span class="hljs-string">'YGJHJHGJAHSGJDHGSJGJHDGSJHS'</span>)xhr.send()</code></pre><p>这个例子中，我们发送了一个POST请求，并在它的请求头中添加了一个自定义的 <code>X-Token</code> 和 <code>X-Test</code> 字段，因为添加了自定义请求头字段，所以它是一个非简单请求</p><p>那么这个非简单请求在预检请求头信息中就会携带以下信息</p><pre><code class="hljs html">// 来源Origin: http://www.hahaha.com// 该CORS请求的请求方法Access-Control-Request-Method: POST// 额外发出的头信息字段Access-Control-Request-Headers: X-Token, X-Test</code></pre><h4 id="withCredentials属性"><a href="#withCredentials属性" class="headerlink" title="withCredentials属性"></a>withCredentials属性</h4><p>CORS 请求默认不发送 Cookie 和 HTTP 认证信息</p><p>如果要把 Cookie 发到服务端，首先要服务端同意，指定<code>Access-Control-Allow-Credentials</code> 字段</p><pre><code class="hljs yaml"><span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span></code></pre><p>其次，客户端必须在发起的请求中打开 <code>withCredentials</code> 属性</p><pre><code class="hljs ini"><span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-attr">xhr.withCredentials</span> = <span class="hljs-literal">true</span></code></pre><p>不然的话，服务端和客户端有一个没设置，就不会发送或处理Cookie</p><p>虽说浏览器默认不发送 Cookie 和 HTTP 认证信息，但是有的浏览器，还是会一起发送Cookie，这时你也可以显式关闭 <code>withCredentials</code></p><pre><code class="hljs ini"><span class="hljs-attr">xhr.withCredentials</span> = <span class="hljs-literal">false</span></code></pre><p>注意，如要发送 <code>Cookie</code>，<code>Access-Control-Allow-Origin</code> 字段就不能设为星号，必须指定明确的、与请求网页一致的域名，同时，<code>Cookie</code> 依然遵循同源政策，只有用服务器域名设置的 <code>Cookie</code> 才会上传，其他域名的 <code>Cookie</code> 并不会上传，且（跨源）原网页代码中的 <code>document.cookie</code> 也无法读取服务器域名下的 <code>Cookie</code> ，下面还会提到</p><h4 id="服务端CORS跨域配置"><a href="#服务端CORS跨域配置" class="headerlink" title="服务端CORS跨域配置"></a>服务端CORS跨域配置</h4><p>上面的东西只是为了让我们理解CORS，但是要解决它还是需要服务端配置的，不同语言的配置项语法上可能有差异，但是内容肯定都是一样的</p><p><strong>配置允许跨域的来源</strong></p><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: *</code></pre><p><code>CORS</code> 跨域请求中，最关键的就是 <code>Access-Control-Allow-Origin</code> 字段，是必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为星号，表示同意任意跨源请求</p><p>注意，将此字段设置为 <code>*</code> 是很不安全的，建议指定来源，并且设置为 <code>*</code> 号后，游览器将不会发送 <code>Cookie</code>，即使你的 <code>XHR</code> 设置了 <code>withCredentials</code>，也不会发送 <code>Cookie</code></p><p><strong>配置允许跨域请求的方法</strong></p><pre><code class="hljs gams">Access-Control-Allow-Methods: GET, POST, <span class="hljs-keyword">OPTIONS</span>, <span class="hljs-keyword">PUT</span>...</code></pre><p>该字段也是必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p><p><strong>配置允许的请求头字段</strong></p><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Headers: x-requested-<span class="hljs-keyword">with</span>,content-<span class="hljs-keyword">type</span>...</code></pre><p>如果你的请求中有自定义的请求头字段，那么此项也是必须的，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</p><p><strong>配置是否允许发送Cookie</strong></p><pre><code class="hljs yaml"><span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span></code></pre><p>该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中</p><p>设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p><p>该字段只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p><p><strong>配置本次预检请求的有效期</strong></p><pre><code class="hljs fortran"><span class="hljs-keyword">Access</span>-Control-<span class="hljs-built_in">Max</span>-Age: <span class="hljs-number">1728000</span></code></pre><p>该字段可选，用来指定本次预检请求的有效期，单位为秒，上面结果中，有效期是20天（1728000秒），即允许缓存该条回应20天，在此期间如果你再次发出了这个接口请求，就不用发预检请求了，节省服务端资源</p><h4 id="常见的跨域预检请求抛错"><a href="#常见的跨域预检请求抛错" class="headerlink" title="常见的跨域预检请求抛错"></a>常见的跨域预检请求抛错</h4><p>对于我们开发时，在跨域中最容易碰钉子的地方就是预检请求，所以列举几个预检请求错误的原因，知道哪错了可以直接找后端同学理论，关于预检请求，最终目的只有一个，客户端发送预检，服务端允许并返回200即可</p><p><strong>OPTIONS 404</strong></p><pre><code class="hljs routeros"><span class="hljs-literal">No</span> <span class="hljs-string">'Access-Control-Allow-Origin'</span> header is present on the requested resource且 The response had HTTP status code 404</code></pre><p>服务端没有设置允许 <code>OPTIONS</code> 请求，那么在发起该预检请求时响应状态码会是404，因为无法找到对应接口地址</p><p>那么你可能需要找到后端，优雅的告诉他，请允许下 <code>OPTIONS</code> 请求</p><p><strong>OPTIONS 405</strong></p><pre><code class="hljs routeros"><span class="hljs-literal">No</span> <span class="hljs-string">'Access-Control-Allow-Origin'</span> header is present on the requested resource且 The response had HTTP status code 405</code></pre><p>服务端已经允许了 <code>OPTIONS</code> 请求，但是一些配置文件中（如安全配置）阻止了 <code>OPTIONS</code> 请求</p><p>那么你可能需要找到后端，优雅的告诉他，请关闭对应的安全配置</p><p><strong>OPTIONS 200</strong></p><pre><code class="hljs routeros"><span class="hljs-literal">No</span> <span class="hljs-string">'Access-Control-Allow-Origin'</span> header is present on the requested resource且 OPTIONS 请求 status 为 200</code></pre><p>服务器端允许了 <code>OPTIONS</code> 请求，配置文件中也没有阻止，但是头部匹配时出现不匹配现象</p><p>所谓头部匹配，就比如 <code>Origin</code> 头部检查不匹配，或者少了一些头部的支持（如 <code>X-Requested-With</code> 等）,然后服务端就会将 <code>Response</code> 返回给前端，前端检测到这个后就触发 <code>XHR.onerror</code> ，从而导致报错</p><p>那么你可能需要找到后端，优雅的告诉他，请增加对应的头部支持</p><p><strong>OPTIONS 500</strong></p><p>这个就更简单了，服务端针对 <code>OPTIONS</code> 请求的代码出了问题，或者没有响应</p><p>那么你可能需要找到后端，将 <code>Network</code> 中的错误信息截一图发给他，优雅的告诉他，检测到预检请求时，请把它搞成200</p><h3 id="No-7-Nginx代理跨域"><a href="#No-7-Nginx代理跨域" class="headerlink" title="No.7 Nginx代理跨域"></a>No.7 Nginx代理跨域</h3><h4 id="iconfont跨域解决"><a href="#iconfont跨域解决" class="headerlink" title="iconfont跨域解决"></a>iconfont跨域解决</h4><p>浏览器跨域访问 <code>js/css/img</code> 等常规静态资源时被同源策略许可的，但 <code>iconfont</code> 字体文件比如 <code>eot|otf|ttf|woff|svg</code> 例外，此时可在 <code>Nginx</code> 的静态资源服务器中加入以下配置来解决</p><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title">  add_header</span> Access-Control-Allow-Origin *;&#125;</code></pre><h4 id="反向代理接口跨域"><a href="#反向代理接口跨域" class="headerlink" title="反向代理接口跨域"></a>反向代理接口跨域</h4><p>我们知道同源策略只是 <strong>浏览器</strong> 的安全策略，不是 <code>HTTP</code> 协议的一部分， 服务器端调用 <code>HTTP</code> 接口只是使用 <code>HTTP</code> 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题</p><p>通俗点说就是客户端浏览器发起一个请求会存在跨域问题，但是服务端向另一个服务端发起请求并无跨域，因为跨域问题归根结底源于同源策略，而同源策略只存在于浏览器</p><p>那么我们是不是可以通过 <code>Nginx</code> 配置一个代理服务器，反向代理访问跨域的接口，并且我们还可以修改 <code>Cookie</code> 中 <code>domain</code> 信息，方便当前域 <code>Cookie</code> 写入</p><p><code>Nginx</code> 其实就是各种配置，简单易学，就算没接触过，也很好理解，我们来看示例</p><p>首先假如我们的页面 a 在 <code>http://www.hahaha.com</code> 域下，但是我们的接口却在 <code>http://www.hahaha1.com:9999</code> 域下</p><p>接着我们在页面 a 发起一个 <code>AJAX</code> 请求时，就会跨域，那么我们就可以通过 <code>Nginx</code> 配置一个代理服务器，域名和页面 a 相同，都是 <code>http://www.hahaha.com</code> ，用它来充当一个跳板的角色，反向代理访问  <code>http://www.hahaha1.com</code>  接口</p><pre><code class="hljs bash"><span class="hljs-comment"># Nginx代理服务器</span>server &#123;  listen       80;  server_name  www.hahaha.com;  location / &#123;    <span class="hljs-comment"># 反向代理地址</span>    proxy_pass   http://www.hahaha1.com:9999;      <span class="hljs-comment"># 修改Cookie中域名</span>    proxy_cookie_domain www.hahaha1.com www.hahaha.com;     index  index.html index.htm;    <span class="hljs-comment"># 前端跨域携带了Cookie，所以Allow-Origin配置不可为*</span>    add_header Access-Control-Allow-Origin http://www.hahaha.com;      add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;  &#125;&#125;</code></pre><p>没错，这个代理配置相信没接触过 <code>Nginx</code> 也能看明白，大部分都是我们上文提到过的，是不是很简单呢</p><h3 id="No-8-Node代理跨域"><a href="#No-8-Node代理跨域" class="headerlink" title="No.8 Node代理跨域"></a>No.8 Node代理跨域</h3><p><code>Node</code> 实现跨域代理，与 <code>Nginx</code> 道理相同，都是启一个代理服务器，就像我们常用的 <code>Vue-CLI</code> 配置跨域，其实也是 <code>Node</code> 启了一个代理服务，接下来我们来看看是如何做的</p><h4 id="Vue-CLI中代理的多种配置"><a href="#Vue-CLI中代理的多种配置" class="headerlink" title="Vue-CLI中代理的多种配置"></a>Vue-CLI中代理的多种配置</h4><p>Vue-CLI 是基于 <code>webpack</code> 的，通过 <code>webpack-dev-server</code> 在本地启动脚手架，也就是在本地启动了一个 <code>Node</code> 服务，来实时监听和打包编译静态资源，由于都是封装好的，只需要配置即可，我们在 <code>vue.config.js</code> 中配置代理如下，写法很多，列几个常见的自行选择</p><p><strong>使用一</strong></p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    proxy: &#123;      <span class="hljs-string">'/api'</span>: <span class="hljs-string">'http://www.hahaha.com'</span>    &#125;  &#125;&#125;</code></pre><p>如上所示时，当你请求 <code>/api/abc</code> 接口时就会被代理到 <code>http://www.hahaha.com/api/abc</code></p><p><strong>使用二</strong></p><p>当然，你可能想将多个路径代理到同一个 <code>target</code> 下，那你可以使用下面这种方式</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    proxy: [&#123;      context: [<span class="hljs-string">'/api1'</span>, <span class="hljs-string">'/api2'</span>, <span class="hljs-string">'/api3'</span>],      target: <span class="hljs-string">'http://www.hahaha.com'</span>,    &#125;]  &#125;&#125;</code></pre><p><strong>使用三</strong></p><p>正如我们第一种使用方式代理时，代理了 <code>/api</code> ，最终的代理结果是 <code>http://www.hahaha.com/api/abc</code> ，但是有时我们并不想代理时传递 <code>/api</code>，那么就可以使用下面这种方式，通过 <code>pathRewrite</code> 属性来进行路径重写</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    proxy: &#123;      <span class="hljs-string">'/api'</span>: &#123;        target: <span class="hljs-string">'http://www.hahaha.com'</span>,        pathRewrite: &#123;<span class="hljs-string">'^/api'</span> : <span class="hljs-string">''</span>&#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>这个时候，<code>/api/abc</code> 接口就会被代理到 <code>http://www.hahaha.com/abc</code></p><p><strong>使用四</strong></p><p>默认情况下，我们代理是不接受运行在 <code>HTTPS</code> 上，且使用了无效证书的后端服务器的</p><p>如果你想要接受，需要设置 <code>secure: false</code> ，如下</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    proxy: &#123;      <span class="hljs-string">'/api'</span>: &#123;        target: <span class="hljs-string">'https://www.hahaha.com'</span>,        secure: <span class="hljs-literal">false</span>      &#125;    &#125;  &#125;&#125;</code></pre><p><strong>使用五</strong></p><p>配置一个字段 <code>changeOrigin</code> ，当它为 <code>true</code> 时，本地就会虚拟一个服务器接收你的请求并且代你发送该请求，所以如果你要代理跨域，这个字段是必选项</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">// ...</span>  devServer: &#123;    proxy: &#123;      <span class="hljs-string">"/api"</span>: &#123;        target: <span class="hljs-string">'http://www.hahaha.com'</span>,        changeOrigin: <span class="hljs-literal">true</span>,      &#125;    &#125;  &#125;&#125;</code></pre><p><strong>使用六</strong></p><p>如果你想配置多个不同的代理，也简单，如下所示，可以在任意代理中设置对应的代理规则</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">// ...</span>  devServer: &#123;    proxy: &#123;      <span class="hljs-string">"/api1"</span>: &#123;        target: <span class="hljs-string">'http://www.hahaha1.com'</span>,        changeOrigin: <span class="hljs-literal">true</span>      &#125;,      <span class="hljs-string">"/api2"</span>: &#123;        target: <span class="hljs-string">'http://www.hahaha2.com'</span>,        pathRewrite: &#123;<span class="hljs-string">'^/api2'</span> : <span class="hljs-string">''</span>&#125;      &#125;,      <span class="hljs-string">"/api3"</span>: &#123;        target: <span class="hljs-string">'http://www.hahaha3.com'</span>,        changeOrigin: <span class="hljs-literal">true</span>,        pathRewrite: &#123;<span class="hljs-string">'^/api3'</span> : <span class="hljs-string">''</span>&#125;      &#125;      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;</code></pre><p>注意，在本地配置代理跨域，只是解决开发时的跨域问题，当你的项目上线时，前端静态文件和后端在一个域下没有问题，如果并不在一个域下，依然会报跨域错误，这个时候还得需要后端配置跨域</p><h4 id="Node实现代理服务器"><a href="#Node实现代理服务器" class="headerlink" title="Node实现代理服务器"></a>Node实现代理服务器</h4><p>这里我们使用 <code>express + http-proxy-middleware</code> 来搭建一个代理服务器，使用 <code>http-proxy-middleware</code> 这个中间件没有别的意思，只是因为 <code>webpack-dev-server</code> 里就是使用的它</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<span class="hljs-keyword">let</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http-proxy-middleware'</span>)<span class="hljs-keyword">let</span> app = express()app.use(<span class="hljs-string">'/'</span>, proxy(&#123;    <span class="hljs-comment">// 代理跨域目标接口</span>    target: <span class="hljs-string">'http://www.hahaha1.com:9999'</span>,    changeOrigin: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span>    onProxyRes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proxyRes, req, res</span>) </span>&#123;        res.header(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'http://www.hahaha.com'</span>)        res.header(<span class="hljs-string">'Access-Control-Allow-Credentials'</span>, <span class="hljs-string">'true'</span>)    &#125;,    <span class="hljs-comment">// 修改响应信息中的cookie域名，为false时，表示不修改</span>    cookieDomainRewrite: <span class="hljs-string">'www.hahaha.com'</span>&#125;))app.listen(<span class="hljs-number">3000</span>)</code></pre><h3 id="No-9-WebSocket跨域"><a href="#No-9-WebSocket跨域" class="headerlink" title="No.9 WebSocket跨域"></a>No.9 WebSocket跨域</h3><h4 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h4><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 <code>RFC 6455</code>，并由 <code>RFC7936</code> 补充规范，<code>WebSocket API</code> 也被 W3C 定为标准</p><p><code>WebSocket</code> 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案</p><h4 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h4><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易</li><li>与 HTTP 协议有着良好的兼容性，默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>可以发送文本，也可以发送二进制数据</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL</li></ul><p>如下</p><pre><code class="hljs vim"><span class="hljs-keyword">w</span><span class="hljs-variable">s:</span>//www.hahaha.<span class="hljs-keyword">com</span>:<span class="hljs-number">80</span>/<span class="hljs-keyword">abc</span>/def</code></pre><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>每个服务端语言对 <code>websocket</code> 有相应的支持，写法不同罢了，这里我们使用 <code>Node</code> 做示例</p><p>在客户端我们可以直接使用 HTML5 的 <code>websocket API</code> ，服务端也可以使用 <code>nodejs-websocket</code> 实现 <code>websocket server</code> ，但是不建议这样做，因为原生 <code>WebSocket API</code> 使用起有些复杂，在浏览器的兼容性上还不够理想，所以我们使用 <code>Socket.io</code>，它很好地封装了 <code>webSocket</code> 接口，提供了更简单、灵活的接口，也对不支持 <code>webSocket</code> 的浏览器提供了向下兼容，使用 <code>Socket.io</code> 库实现 <code>websocket</code>，在发送数据时可以直接发送可序列化的对象，也可以自定义消息，利用事件字符串来区分不同消息，整个开发过程会舒服很多</p><p>想要了解更多看官网即可 <a href="https://socket.io/" target="_blank" rel="noopener">Socket.io - 传送门</a> ，我们来看示例</p><p>客户端：<code>http://www.hahaha.com/a.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/socket.io/socket.io.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> socket = io.connect(<span class="hljs-string">'http://www.hahaha1.com:3000'</span>)</span>  <span class="actionscript">  socket.on(<span class="hljs-string">'my event'</span>, (data) =&gt; &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// &#123; hello: 'world' &#125;</span></span>    <span class="actionscript">    socket.emit(<span class="hljs-string">'my other event'</span>, &#123; my: <span class="hljs-string">'data'</span> &#125;)</span>  &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>服务端：<code>http://www.hahaha1.com:3000</code></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>).createServer()<span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">'socket.io'</span>)(app)app.listen(<span class="hljs-number">3000</span>)io.on(<span class="hljs-string">'connection'</span>, (socket) =&gt; &#123;  socket.emit(<span class="hljs-string">'my event'</span>, &#123; <span class="hljs-attr">hello</span>: <span class="hljs-string">'world'</span> &#125;)    socket.on(<span class="hljs-string">'my other event'</span>, (data) =&gt; &#123;    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// &#123; my: 'data' &#125;</span>  &#125;)&#125;)</code></pre><p>如上所示，使用了 <code>Socket.io</code> 之后的 <code>websocket</code> 连接是不是超级简单呢，跟着文档自己动手试试吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于js中改变this指向问题</title>
    <link href="/2019-1-29-%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <url>/2019-1-29-%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-改变this指向三种方法"><a href="#1-改变this指向三种方法" class="headerlink" title="1.改变this指向三种方法"></a>1.改变this指向三种方法</h2><h5 id="1-call"><a href="#1-call" class="headerlink" title="1.call"></a>1.call</h5><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;  name: <span class="hljs-string">'evan'</span>,  age: <span class="hljs-number">18</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">this</span>.age, a, b);&#125;fn.call(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre><p>调用fn并使用obj中的this</p><h5 id="2-apply"><a href="#2-apply" class="headerlink" title="2.apply"></a>2.apply</h5><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;  name: <span class="hljs-string">'evan'</span>,  age: <span class="hljs-number">18</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">this</span>.age, a, b);&#125;fn.apply(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</code></pre><p>调用fn并使用obj中的this</p><h6 id="两者的不同在于参数数组的区别-如果参数复杂就用call-如何不复杂就用apply-视情况而定"><a href="#两者的不同在于参数数组的区别-如果参数复杂就用call-如何不复杂就用apply-视情况而定" class="headerlink" title="两者的不同在于参数数组的区别,如果参数复杂就用call,如何不复杂就用apply,视情况而定"></a>两者的不同在于参数数组的区别,如果参数复杂就用call,如何不复杂就用apply,视情况而定</h6><h5 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind"></a>3.bind</h5><p>bind和其他两者的区别是返回的是一个改变this指向的函数,而不是直接调用(call和apply返回的是undefined)</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;  name: <span class="hljs-string">'evan'</span>,  age: <span class="hljs-number">18</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">this</span>.age, a, b);&#125;<span class="hljs-keyword">const</span> a = fn.bind(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)a()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJS、AMD、CMD、ES6 模块规范讲解</title>
    <link href="/2019-1-24-CommonJS%E3%80%81AMD%E3%80%81CMD%E3%80%81ES6-%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E8%AE%B2%E8%A7%A3/"/>
    <url>/2019-1-24-CommonJS%E3%80%81AMD%E3%80%81CMD%E3%80%81ES6-%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化原始写法"><a href="#模块化原始写法" class="headerlink" title="模块化原始写法"></a>模块化原始写法</h1><p>在没有<code>CommonJS</code>和<code>ES6</code>的时候，我们想要达到模块化的效果可能有这么三种：</p><h2 id="1-一个函数就是一个模块"><a href="#1-一个函数就是一个模块" class="headerlink" title="1. 一个函数就是一个模块"></a>1. 一个函数就是一个模块</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>  <span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">m1</span> <span class="hljs-params">()</span> </span>&#123;  </span><span class="actionscript">    <span class="hljs-comment">// ...  </span></span>  &#125;  <span class="actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">m2</span> <span class="hljs-params">()</span> </span>&#123;  </span><span class="actionscript">    <span class="hljs-comment">// ...  </span></span>  &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><blockquote><p>缺点：污染了全局变量，无法保证不会与其它模块发生冲突，而且模块成员之间看不出直接关系。</p></blockquote><h2 id="2-一个对象就是一个模块"><a href="#2-一个对象就是一个模块" class="headerlink" title="2. 一个对象就是一个模块"></a>2. 一个对象就是一个模块</h2><p>对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p><p><strong>index.html</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>  <span class="javascript">  <span class="hljs-keyword">var</span> module1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;  </span>    _sum: 0,  <span class="actionscript">    foo1: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;,  </span><span class="actionscript">    foo2: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;  </span>  &#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><blockquote><p>缺点：会暴露所有模块成员，内部的状态可能被改写。</p></blockquote><p>例如，我们如果只是想暴露出两个方法而不暴露出 <code>_sum</code>，就做不到。</p><p>而此时，<code>_sum</code> 可能被外部改写：</p><pre><code class="hljs js">module1._sum = <span class="hljs-number">2</span>;</code></pre><h2 id="3-立即执行函数为一个模块"><a href="#3-立即执行函数为一个模块" class="headerlink" title="3. 立即执行函数为一个模块"></a>3. 立即执行函数为一个模块</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>  <span class="actionscript">  <span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;  </span><span class="actionscript">    <span class="hljs-keyword">var</span> _sum = <span class="hljs-number">0</span>;  </span><span class="actionscript">    <span class="hljs-keyword">var</span> foo1 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;;  </span><span class="actionscript">    <span class="hljs-keyword">var</span> foo2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;;  </span><span class="actionscript">    <span class="hljs-keyword">return</span> &#123;  </span>      foo1: foo1,        foo2: foo2      &#125;    &#125;)();  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>利用立即执行函数内的作用域已经闭包来实现模块功能，导出我们想要导出的成员。</p><p>此时外部代码就不能读取到 <code>_sum</code> 了：</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(module1._sum) <span class="hljs-comment">// undefined</span></code></pre><h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1><p>这里不做具体的介绍了，我只把一些重要的知识点以及混淆点例举出来。</p><p>主要是从这四个方面说：</p><ul><li>暴露模块</li><li>引用模块</li><li>模块标识符</li><li>CommonJS规范的特点</li></ul><h2 id="1-暴露-定义-模块"><a href="#1-暴露-定义-模块" class="headerlink" title="1. 暴露(定义)模块"></a>1. 暴露(定义)模块</h2><p><strong>正确的暴露方式：</strong></p><p>暴露模块有两种方式：</p><ul><li><code>module.exports = {}</code></li><li><code>exports.xxx = &#39;xxx&#39;</code></li></ul><p>例如有一个 <code>m1.js</code> 文件：</p><p>第一种暴露方式：</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>  &#125;</code></pre><p>第二种暴露方式：</p><pre><code class="hljs js">exports.name = <span class="hljs-string">'evanchen'</span>;  exports.sex = <span class="hljs-string">'boy'</span></code></pre><p>为什么可以有这两种写法呢？</p><p>我是这样理解的：<code>module</code>这个变量它代表的就是整个模块，也就是<code>m1.js</code>。而其实这个<code>module</code>变量是有一个属性<code>exports</code>的，它是一个叫做<code>exports</code>变量的引用，我们可以写一下伪代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> exports = &#123;&#125;;  <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = &#123;      exports: exports  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports</code></pre><p>(当然这只是伪代码啊，实际你这么去用会发现没有效果)</p><p>最后导出的是<code>module.exports</code>，而不是<code>exports</code>。</p><p><strong>容易混淆的暴露方式：</strong></p><p>如果你在代码中试图 <code>exports = { name: &#39;evanchen&#39; }</code>，你会发现在引入的地方根本获取不到<code>name</code>属性。</p><pre><code class="hljs js"><span class="hljs-comment">// m1.js  </span>exports = &#123;      name: <span class="hljs-string">'evanchen'</span>  &#125;<span class="hljs-comment">// test.js</span><span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1.js'</span>)    <span class="hljs-built_in">console</span>.log(m1); <span class="hljs-comment">// &#123;&#125;</span></code></pre><p>在控制台执行 <code>node test.js</code>，发现打印出来的 <code>m1</code> 是一个空的对象。</p><p>我是这样理解的：整个模块的导出是靠 <code>module.exports</code>的，如果你重新对整个 <code>exports</code> 对象赋值的话，它和 <code>module.exports</code> 就不是同一个对象了，因为它们指向的引用地址都不同：</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports -&gt; &#123;&#125; <span class="hljs-comment">// 指向一个空的对象  </span>exports -&gt; &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'evanchen'</span> &#125; <span class="hljs-comment">// 指向的是另一个对象</span></code></pre><p>所以你对 <code>exports = {}</code> 做任何操作都影响不到 <code>module.exports</code>。</p><p>让我们来看几个正确和错误的示例吧：</p><pre><code class="hljs js"><span class="hljs-comment">// m1.js</span><span class="hljs-comment">// 1. 正确  </span><span class="hljs-built_in">module</span>.exports = &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>  &#125;    <span class="hljs-comment">// 2. 正确  </span>exports.name = <span class="hljs-string">'evanchen'</span>;  exports.sex = <span class="hljs-string">'boy'</span>    <span class="hljs-comment">// 3. 正确  </span><span class="hljs-built_in">module</span>.exports.name = <span class="hljs-string">'evanchen'</span>;  <span class="hljs-built_in">module</span>.exports.sex = <span class="hljs-string">'boy'</span>    <span class="hljs-comment">// 4. 无效  </span>exports = &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>  &#125;</code></pre><p>可以看到</p><ul><li><code>exports.name = xxx</code> 是 <code>module.exports.name = xxx</code> 的缩写。</li><li><code>exports = {}</code> 却不是 <code>module.exports = {}</code> 的缩写。</li></ul><h2 id="2-引用-引入-模块"><a href="#2-引用-引入-模块" class="headerlink" title="2. 引用(引入)模块"></a>2. 引用(引入)模块</h2><p>对于模块的引用使用全局方法 <code>require()</code> 就可以了。</p><p>注意⚠️这个全局方法是 <code>node</code> 中的方法哈，它不是 <code>window</code> 下面的，所以如果你没做任何处理想直接在 <code>html</code> 里用肯定就是不行的了：</p><p><strong>index.html</strong>:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>  <span class="javascript">        <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1.js'</span>)  </span><span class="javascript">        <span class="hljs-built_in">console</span>.log(m1);  </span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>例如上面👆这样你打开页面控制台肯定就报错了：</p><pre><code class="hljs js">Uncaught <span class="hljs-built_in">ReferenceError</span>: <span class="hljs-built_in">require</span> is not defined      at index.html:<span class="hljs-number">11</span></code></pre><p>而如果你是在另一个 <code>js</code> 文件中引用(例如 <code>test.js</code> )，并在终端执行 <code>node test.js</code> 是可以用的：</p><p><strong>test.js</strong>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1.js'</span>)    <span class="hljs-built_in">console</span>.log(m1);</code></pre><p>那是因为你的电脑上全局安装了 <code>Node.js</code>，所以可以这样玩。</p><p><strong>所以我们可以发现 <code>require()</code> 它是 <code>Node.js</code> 中的一个全局方法，并不是CommonJS独有的，CommonJS只是众多规范中的其中一种。</strong></p><p>这种规范允许我们：</p><ul><li>使用 <code>module.exports = {}</code> 或者 <code>exports.name = xxx</code> 导出模块</li><li>使用 <code>const m1 = require(&#39;./m1&#39;)</code> 引入模块</li></ul><p>注意⚠️：</p><p>另外还有一点比较重要，那就是 <code>require()</code> 的参数甚至能允许你是一个表达式。</p><p>也就是说你可以把它设置为一个变量：</p><p><strong>test.js</strong>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> m1Url = <span class="hljs-string">'./m1.js'</span>;  <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(m1Url);    <span class="hljs-comment">// 甚至做一些字符串拼接：  </span><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m'</span> + <span class="hljs-string">'1.js'</span>);</code></pre><h2 id="3-模块标识符-标识"><a href="#3-模块标识符-标识" class="headerlink" title="3. 模块标识符(标识)"></a>3. 模块标识符(标识)</h2><p>模块标识符其实就是你在引入模块时调用 <code>require()</code> 函数的参数。</p><p>你会看到我们经常会有这样的用法：</p><pre><code class="hljs js"><span class="hljs-comment">// 直接导入  </span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);  <span class="hljs-comment">// 相对路径  </span><span class="hljs-keyword">const</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1.js'</span>);  <span class="hljs-comment">// 直接导入  </span><span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);</code></pre><p>这其实是因为我们引入的模块会有不同的分类，像<code>path</code>这种它是<code>Node.js</code>就自带的模块，<code>m1</code>是路径模块，<code>lodash</code>是我们使用<code>npm i lodash</code>下载到<code>node_modules</code>里的模块。</p><p>分为以下三种：</p><ul><li>核心模块(<code>Node.js</code>自带的模块)</li><li>路径模块(相对或绝对定位开始的模块)</li><li>自定义模块(<code>node_modules</code>里的模块)</li></ul><p>三种模块的查找方式：</p><ul><li>核心模块，直接跳过路径分析和文件定位</li><li>路径模块，直接得出相对路径就好了</li><li>自定义模块，先在当前目录的<code>node_modules</code>里找这个模块，如果没有，它会往上一级目录查找，查找上一级的<code>node_modules</code>，依次往上，直到根目录下都没有, 就抛出错误。</li></ul><p><strong>自定义模块的查找过程：</strong></p><p>这个过程其实也叫做<strong>路径分析</strong>。</p><p>现在我把刚刚的<code>test.js</code>来改一下：</p><pre><code class="hljs js"><span class="hljs-comment">// var m1 = require('./m1.js');  </span>  <span class="hljs-comment">// console.log(m1);  </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.paths)</code></pre><p>然后在终端执行：</p><pre><code class="hljs bash">node test.js</code></pre><p>会发现输出了下面的一个数组：</p><pre><code class="hljs bash">node test.js  [    <span class="hljs-string">'/Users/evanchen/codes/test/CommonJS和ES6/commonJS/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/test/CommonJS和ES6/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/test/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/node_modules'</span>,    <span class="hljs-string">'/Users/node_modules'</span>,    <span class="hljs-string">'/node_modules'</span>  ]</code></pre><p>这里所说的查找，是指查找你现在用的这个模块，我现在用的是<code>test.js</code>，你可能看不出什么效果。现在让我们来模拟一个我们使用<code>npm i</code>安装的一个自定义模块功能。</p><p>首先，我在根目录下新建了一个名叫<code>node_modules</code>的文件夹，并在其中新建了一个名叫<code>evanchen.js</code>的文件，用来模拟一个<code>npm</code>安装的依赖。</p><p>目录结构：</p><p><img src="https://segmentfault.com/img/remote/1460000022599814" srcset="/img/loading.gif" alt="img"></p><p>稍微编写一下<code>evanchen.js</code>:</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'evanchen'</span>)    &#125;  &#125;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'evanchen模块：'</span>, <span class="hljs-built_in">module</span>.paths)</code></pre><p>然后在<code>test.js</code>中引入这个<code>evanchen</code>模块:</p><pre><code class="hljs js"><span class="hljs-comment">// var m1 = require('./m1.js');  </span><span class="hljs-comment">// console.log(m1);  </span><span class="hljs-comment">// console.log(module.paths)  </span>  <span class="hljs-keyword">var</span> evanchen = <span class="hljs-built_in">require</span>(<span class="hljs-string">'evanchen'</span>);  evanchen.print();</code></pre><p>现在执行<code>node test.js</code>，会发现输出了：</p><pre><code class="hljs js">node test.js  evanchen模块： [    <span class="hljs-string">'/Users/evanchen/codes/test/CommonJS和ES6/commonJS/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/test/CommonJS和ES6/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/test/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/codes/node_modules'</span>,    <span class="hljs-string">'/Users/evanchen/node_modules'</span>,    <span class="hljs-string">'/Users/node_modules'</span>,    <span class="hljs-string">'/node_modules'</span>  ]  evanchen</code></pre><p>所以现在你可以知道，平常我们使用这种依赖的时候，它是怎样的一个查找顺序了吧，它其实就是按照自定义模块的顺序来进行查找。</p><p><strong>文件定位：</strong></p><p>上面👆已经介绍完了路径分析，但是还有一个问题，就是我们导入的模块它的后缀(扩展名)是可以省略的啊，那<code>Node</code>怎么知道我们是导入了一个<code>js</code>还是一个<code>json</code>呢？这其实就涉及到了文件定位。</p><p>在NodeJS中, 省略了扩展名的文件, 会依次补充上.js, .node, .json来尝试, 如果传入的是一个目录, 那么NodeJS会把它当成一个包来看待, 会采用以下方式确定文件名</p><p>第一步, 找出目录下的package.json, 用JSON.parse()解析出main字段</p><p>第二步, 如果main字段指定的文件还是省略了扩展, 那么会依次补充.js, .node, .json尝试.</p><p>第三步, 如果main字段制定的文件不存在, 或者根本就不存在package.json, 那么会默认加载这个目录下的index.js, index.node, index.json文件.</p><p>以上就是文件定位的过程, 再搭配上路径分析的过程, 进行排列组合, 这得有多少种可能呀. 所以说, 自定义模块的引入, 是最费性能的.</p><h2 id="4-CommonJS规范的特点"><a href="#4-CommonJS规范的特点" class="headerlink" title="4. CommonJS规范的特点"></a>4. CommonJS规范的特点</h2><p>我先把<code>CommonJS</code>规范的一些特点列举出来吧，然后我们再一点一点的去看例子。</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作；</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；</li><li>CommonJS输出是值的拷贝(即，<code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。</li></ul><p>(总结来源：<a href="https://juejin.im/post/5db95e3a6fb9a020704bcd8d" target="_blank" rel="noopener">https://juejin.im/post/5db95e…</a>)</p><p>第一点还是好理解的，咱模块的一个重要的功能不就是这个吗。</p><p>第二点<strong>同步加载</strong>，这个写个案例我们来验证一下</p><p><strong>同步加载案例</strong>：</p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是m1模块'</span>)  <span class="hljs-built_in">module</span>.exports = &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>  &#125;</code></pre><p><em>test.js</em></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1'</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是test模块'</span>);</code></pre><p>可以看到，<code>test</code>模块依赖于<code>m1</code>，且是先下载的<code>m1</code>模块，所以如果我执行<code>node test.js</code>，会有以下的执行结果：</p><pre><code class="hljs js">node test.js  我是m1模块  我是test模块</code></pre><p>这也就验证了<code>CommonJS</code>中，模块是同步加载的，即只有加载完成，才能执行后面的操作。</p><p>第三点<strong>模块首次执行后会缓存</strong>，我们也可以写个案例来验证一下。</p><p><strong>模块首次执行后会缓存案例：</strong></p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'evanchen'</span>;  <span class="hljs-keyword">var</span> sex = <span class="hljs-string">'boy'</span>;    exports.name = name;  exports.sex = sex;</code></pre><p><em>test.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1'</span>);  m1.sex = <span class="hljs-string">'girl'</span>;  <span class="hljs-built_in">console</span>.log(m1);    <span class="hljs-keyword">var</span> m2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1'</span>);  <span class="hljs-built_in">console</span>.log(m2);</code></pre><p><code>test</code>同样依赖于<code>m1</code>，但是我会在其中导入两次<code>m1</code>，第一次导入的时候修改了<code>m1.sex</code>的值，第二次的时候命名为<code>m2</code>，但是结果<code>m1</code>和<code>m2</code>竟然是相等的：</p><pre><code class="hljs js">LinDaiDaideMBP:commonJS evanchen$ node test.js  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'evanchen'</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">'girl'</span> &#125;  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'evanchen'</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">'girl'</span> &#125;</code></pre><p>也就是说模块在首次执行后就会缓存，再次加载只返回缓存结果，这里我是用了改变<code>m1.sex</code>的值来证明它确实是取了缓存结果。</p><p>那么就有小伙伴会疑惑了，其实你这样写也并不能证明啊，因为你改变了<code>m1.sex</code>也可能是影响原本<code>m1</code>模块里的<code>sex</code>属性呀，这样的话第二次<code>m2</code>拿到的肯定就是被改变的值了。</p><p>唔…我正想证明来着呢。因为<code>CommonJS</code>的第四个特点就可以很好的解决你这个疑问。</p><p>第四点<strong>CommonJS输出是值的拷贝</strong>，也就是说你用<code>require()</code>引入了模块，但是你在最新的模块中怎样去改变，也不会影响你已经<code>require()</code>的模块。来看个案例。</p><p><strong>CommonJS输出是值的拷贝案例</strong>：</p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'evanchen'</span>;  <span class="hljs-keyword">var</span> sex = <span class="hljs-string">'boy'</span>;  <span class="hljs-keyword">var</span> advantage = [<span class="hljs-string">'handsome'</span>]    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    sex = <span class="hljs-string">'girl'</span>;    advantage.push(<span class="hljs-string">'cute'</span>);  &#125;, <span class="hljs-number">500</span>)    exports.name = name;  exports.sex = sex;  exports.advantage = advantage;</code></pre><p><em>test.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1'</span>);  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read count after 1000ms in commonjs is'</span>, m1.sex)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read count after 1000ms in commonjs is'</span>, m1.advantage)  &#125;, <span class="hljs-number">1000</span>)</code></pre><p>执行<code>node test.js</code>之后的执行结果是：</p><pre><code class="hljs js">LinDaiDaideMBP:commonJS evanchen$ node test.js  read count after <span class="hljs-number">1000</span>ms <span class="hljs-keyword">in</span> commonjs is boy  read count after <span class="hljs-number">1000</span>ms <span class="hljs-keyword">in</span> commonjs is [ <span class="hljs-string">'handsome'</span>, <span class="hljs-string">'cute'</span> ]</code></pre><p>也就是说，在开始<code>var m1 = require(&#39;./m1&#39;)</code>的时候，<code>m1</code>已经被引入进来了，但是过了<code>500ms</code>后我改变了原本<code>m1</code>里的一些属性，<code>sex</code>这种基本数据类型是不会被改变的，但是<code>advantage</code>这种引用类型共用的还是同一个内存地址。（这种复制的关系让我想到了之前学原型链继承的时候，它那里也是，会影响<code>Father.prototype</code>上的引用类型）</p><blockquote><p><strong>备注</strong> 其实这里的拷贝是指 JavaScript 的浅拷贝，如果对于 JavaScript 的深浅拷贝有疑问，可以参考 <a href="https://segmentfault.com/a/1190000022416673" target="_blank" rel="noopener">JavaScript 的浅拷贝和深拷贝</a></p></blockquote><p>如果这里你是这样写的话：</p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'evanchen'</span>;  <span class="hljs-keyword">var</span> sex = <span class="hljs-string">'boy'</span>;  <span class="hljs-keyword">var</span> advantage = [<span class="hljs-string">'handsome'</span>]    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    sex = <span class="hljs-string">'girl'</span>;    <span class="hljs-comment">// advantage.push('cute');  </span>  advantage = [<span class="hljs-string">'cute'</span>];  &#125;, <span class="hljs-number">500</span>)    exports.name = name;  exports.sex = sex;  exports.advantage = advantage;</code></pre><p>现在的执行结果肯定就是：</p><pre><code class="hljs js">node test.js  read count after <span class="hljs-number">1000</span>ms <span class="hljs-keyword">in</span> commonjs is boy  read count after <span class="hljs-number">1000</span>ms <span class="hljs-keyword">in</span> commonjs is [ <span class="hljs-string">'handsome'</span> ]</code></pre><p>因为相当于对<code>m1</code>的<code>advantage</code>重新赋值了。</p><p>当然，或者如果你的<code>m1.js</code>中返回的值是会有一个函数的话，在<code>test.js</code>也能拿到变化之后的值了，比如这里的一个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCounter</span>(<span class="hljs-params"></span>) </span>&#123;    counter++;  &#125;  <span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-keyword">get</span> counter() &#123;      <span class="hljs-keyword">return</span> counter    &#125;,    incCounter: incCounter,  &#125;;</code></pre><p>因为在这里实际就形成了一个闭包，而<code>counter</code>属性就是一个取值器函数。</p><p>好滴，这基本就是<code>CommonJS</code>的特点了，总结就不写了，在开头已经说过了，不过对于最后一点：<strong>CommonJS输出是值的拷贝</strong>，这个对于引用类型的变量来说还是会有一点歧义的，比如上面的<code>advantage</code>那个例子，大家知道就行了。</p><h1 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h1><h2 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h2><p>上面介绍的<code>CommonJS</code>规范看起来挺好用的啊，为什么又还要有其它的规范呢？比如<code>AMD、CMD</code>，那它们和<code>CommonJS</code>又有什么渊源呢？</p><p>我们知道，模块化这种概念不仅仅适用于服务器端，客户端同样也适用。</p><p>而<code>CommonJS</code>规范就不太适合用在客户端(浏览器)环境了，比如上面的那个例子，也就是:</p><p><strong>test.js</strong>:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./m1.js'</span>)  <span class="hljs-built_in">console</span>.log(m1);    <span class="hljs-comment">// 与m1模块无关的一些代码  </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">other</span> (<span class="hljs-params"></span>) </span>&#123;&#125;  other();</code></pre><p>这段代码放在浏览器环境中，它会如何运行呢？</p><ul><li>首先加载<code>m1.js</code></li><li>等<code>m1.js</code>加载完毕之后才执行后面的内容</li></ul><p>这点其实在<strong>CommonJS规范的特点</strong>中已经提到过了。</p><p>后面的内容要等待<code>m1</code>加载完才会执行，如果<code>m1</code>加载的很慢呢？那不就造成了卡顿，这对于客户端来说肯定是不友好的。像这种要等待上一个加载完才执行后面内容的情况我们可以叫做<code>&quot;同步加载&quot;</code>，很显然，这里我们更希望的是<code>other()</code>的执行不需要等<code>m1</code>加载完才执行，也就是我们希望<code>m1</code>它是<code>&quot;异步加载&quot;</code>的，这也就是<code>AMD</code>。</p><p>在介绍<code>AMD</code>之前让我们看看<code>CommonJS</code>规范对服务器端和浏览器的不同，它有助于让你理解为什么说<code>CommonJS</code>不太适合于客户端：</p><ul><li>服务器端所有的模块都存放在本地硬盘中，可以同步加载完成，等待时间就是硬盘的读取时间。</li><li>浏览器，所有的模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于<strong>假死</strong>状态。</li></ul><h2 id="2-定义并暴露模块"><a href="#2-定义并暴露模块" class="headerlink" title="2. 定义并暴露模块"></a>2. 定义并暴露模块</h2><p>有了上面这层背景，我们就知道了，<code>AMD</code>它的产生很大一部分原因就是为了能让我们采用<strong>异步的方式加载模块</strong>。</p><p>所以现在来让我们看看它的介绍吧。</p><p><code>AMD</code>是<code>Asynchronous Module Definition</code>的缩写，也就是<code>&quot;异步模块定义&quot;</code>。（前面的<code>A</code>就很好记了，它让我不自觉的就想到<code>async</code>这个定义异步函数的修饰符）</p><blockquote><p>它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p></blockquote><p>此时就需要另一个重要的方法来定义我们的模块：<code>define()</code>。</p><p>它其实是会有三个参数：</p><pre><code class="hljs js">define(id?, dependencies?, factory)</code></pre><ul><li>id: 一个字符串，表示模块的名称，但是是可选的</li><li>dependencies: 一个数组，是我们当前定义的模块要依赖于哪些模块，数组中的每一项表示的是要依赖模块的相对路径，且这个参数也是可选的</li><li>factory: 工厂方法，一个函数，这里面就是具体的模块内容了</li></ul><p><strong>坑一</strong>：</p><p>那其实就有一个问题了，看了这么多的教材，但我想要去写案例的时候，我以为这个<code>define</code>能直接像<code>require</code>一样去用，结果发现控制台一直再报错：</p><pre><code class="hljs js"><span class="hljs-built_in">ReferenceError</span>: define is not defined</code></pre><p>看来它还并不是<code>Node.js</code>自带的一个方法啊，搜寻了一下，原来它只是名义上规定的这样一个方法，但是你真的想要去用还是得使用对应的<code>JavaScript</code>库，也就是我们常常听到的：</p><blockquote><p>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p></blockquote><p>我酸了…</p><p>让我们去requirejs的官网看看如何使用它，由于我的案例都是在<code>Node</code>执行环境中，于是我采用<code>npm install</code>的方式来下载了：</p><p>我新建了一个叫<code>AMD</code>的文件夹，作为<code>AMD</code>的案例。</p><p>在项目的根目录下执行：</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i requirejs</code></pre><p>（找了一圈NPM也没看到能使用<code>CDN</code>远程引入的）</p><p>执行完毕之后，项目的根目录下出现了依赖包，打开看了看，确实是下载下来了：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmz1ltur86j30vl0u0qe7.jpg" srcset="/img/loading.gif" alt="image-20210124201016709"></p><p>现在可以开心的在项目里用<code>define()</code>了 😊。</p><p>来看个小例子，我重新定义了一个<code>math.js</code>：</p><p><strong>math.js</strong></p><pre><code class="hljs js">define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-keyword">return</span> &#123;      add: add    &#125;  &#125;)</code></pre><p>这里模块很简单，导出了一个加法函数。</p><p>(至于这里为什么<code>add: add</code>要这样写，而不是只简写为<code>add</code>呢？别忘了这种对象同名属性简写是<code>ES6</code>才出来的哦)</p><h2 id="3-引用模块"><a href="#3-引用模块" class="headerlink" title="3. 引用模块"></a>3. 引用模块</h2><p><strong>坑二</strong>：</p><p>OK👌，既然模块已经能导出了，那就让我们来看看如何引用吧，依照着教材，我在<code>test.js</code>中引入了<code>math</code>模块并想要调用<code>add()</code>方法：</p><p><strong>test.js</strong>:</p><pre><code class="hljs js"><span class="hljs-built_in">require</span>([<span class="hljs-string">'math'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(math)    <span class="hljs-built_in">console</span>.log(math.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  &#125;)</code></pre><p>之后熟练的执行<code>node test.js</code>。</p><p>我酸了…</p><p>又报错了，擦…</p><pre><code class="hljs js"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ERR_INVALID_ARG_TYPE(name, <span class="hljs-string">'string'</span>, value);   <span class="hljs-built_in">TypeError</span> [ERR_INVALID_ARG_TYPE]: The <span class="hljs-string">"id"</span> argument must be <span class="hljs-keyword">of</span> type string. Received an instance <span class="hljs-keyword">of</span> <span class="hljs-built_in">Array</span></code></pre><p>确认了一下，和教材们中的写法一样啊，第一个参数为要加载的模块数组，第二个参数为加载完之后的回调。</p><p>难受😣…原来上面👆<code>require([modules], callback)</code>这样的写法它和<code>define</code>一样都只是个噱头，如果你真得用的话，还是得用<code>JavaScript</code>库中的方法。</p><p>由于上面已经安装过<code>requirejs</code>了，这里我直接使用就可以了，现在我修改了一下<code>test.js</code>文件：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> requirejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"requirejs"</span>); <span class="hljs-comment">//引入requirejs模块  </span>  requirejs([<span class="hljs-string">'math'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(math)    <span class="hljs-built_in">console</span>.log(math.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  &#125;)</code></pre><p>好了，现在执行<code>node test.js</code>就可以正常使用了…</p><p>（很难受…感觉明明已经是很常见耳熟能详的一些知识了，真的要去用的时候发现和很多教材中说的不是那么一回事…也希望大家在看完了一些教材之后最好能亲自去实践一下，因为自己也是写博客的，所以也知道有些时候一些知识点可能也是从别人的文章那里看来但是没有经过实践的，所以最好也还是自己动动手）</p><h2 id="4-依赖其它模块的define"><a href="#4-依赖其它模块的define" class="headerlink" title="4. 依赖其它模块的define"></a>4. 依赖其它模块的define</h2><p>可以看到<code>define</code>它还有另外两个参数的，第一个是模块的名称，没啥好说的，让我们来看看第二个它所依赖的模块。</p><p>还记得在<code>CommonJS</code>规范那里我们写了一个<code>m1.js</code>吗？现在就让我们把这个模块拿来用下，把它作为<code>math.js</code>中的一个依赖。</p><p><strong>m1.js</strong>:</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是m1, 我被加载了...'</span>)  <span class="hljs-built_in">module</span>.exports = &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>  &#125;</code></pre><p>然后修改一下<code>math.js</code>：</p><p><strong>math.js</strong>:</p><pre><code class="hljs js">define([<span class="hljs-string">'m1'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m1</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是math, 我被加载了...'</span>)    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(m1.name)    &#125;    <span class="hljs-keyword">return</span> &#123;      add: add,      print: print    &#125;  &#125;)</code></pre><p>另外，为了方便大家看，我们再来修改一下刚刚的<code>test.js</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> requirejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"requirejs"</span>); <span class="hljs-comment">//引入requirejs模块  </span>  requirejs([<span class="hljs-string">'math'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是test, 我被加载了...'</span>)    <span class="hljs-built_in">console</span>.log(math.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));    math.print();  &#125;)  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">other</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是test模块内的, 但是我不依赖math'</span>)  &#125;;  other();</code></pre><p>所以我们可以看到，依赖关系依次为：</p><pre><code class="hljs js">test -&gt; math -&gt; m1</code></pre><p>如果按照<code>AMD</code>的规范，模块的加载需要依靠前一个模块加载完才会执行回调函数内的内容，那么我们可以想象当我在终端输入<code>node test.js</code>的时候，要出现的结果应该是：</p><pre><code class="hljs js">LinDaiDaideMBP:commonJS evanchen$ node test.js  我是test模块内的, 但是我不依赖math  我是m1, 我被加载了...  我是math, 我被加载了...  我是test, 我被加载了...  <span class="hljs-number">3</span>  evanchen</code></pre><p>(这个，相信大家应该都看清了彼此的依赖关系吧😢)</p><p>但是现实总是那么的残酷，当我按下回车的时候，又报错了…</p><p>再酸…</p><pre><code class="hljs js"><span class="hljs-built_in">ReferenceError</span>: <span class="hljs-built_in">module</span> is not defined</code></pre><p>看了一下这个报错的内容，是在<code>m1.js</code>中…呆了几秒钟反应了过来…</p><p>既然是使用<code>AMD</code>的规范，那我们肯定是要一统到底了，<code>m1.js</code>中用的还是<code>CommonJS</code>的规范，当然不行了。</p><p>OK，来修改一下<code>m1.js</code>：</p><p><strong>m1.js</strong>:</p><pre><code class="hljs js">define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是m1, 我被加载了...'</span>)    <span class="hljs-keyword">return</span> &#123;      name: <span class="hljs-string">'evanchen'</span>,      sex: <span class="hljs-string">'boy'</span>    &#125;  &#125;)</code></pre><p>OK👌，这次没啥问题了，按照我们预期的去执行了…😊。</p><p>（当然据我的了解，<code>requirejs</code>还可用于在<code>script</code>中引用然后定义网页程序的主模块等使用，可以看一下：</p><p><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">阮一峰require</a></p><p><code>AMD</code>的知识点大概就介绍到了这里，相信大家也知道它的基本使用了吧，至于其中的一些区别什么的我在最后也会列一份清单，不过现在让我们先来看看<code>CMD</code>吧。</p><h1 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h1><blockquote><p>CMD (Common Module Definition), 是seajs推崇的规范，依赖就近，用的时候再require。</p></blockquote><p>来看段代码，大概感受一下它是怎样用的：</p><pre><code class="hljs js">define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>&#123;    <span class="hljs-keyword">var</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./math'</span>);    math.print()  &#125;)</code></pre><p>看着和<code>AMD</code>有点像的，没错，其实<code>define()</code>的参数甚至都是一样的：</p><pre><code class="hljs js">define(id?, dependencies?, factory)</code></pre><p>但是区别在于哪里呢？让我们来看看最后一个<code>factory</code>它参数。</p><p><code>factory</code>函数中是会接收三个参数：</p><ul><li><p><code>require</code></p></li><li><p><code>exports</code></p></li><li><pre><code>module<pre><code class="hljs autohotkey">  这三个很好理解，对应着之前的`CommonJS`那不就是：- `require`：引入某个模块- `exports`：当前模块的`exports`，也就是`module.exports`的简写- `module`：当前这个模块现在再来说说`AMD`和`CMD`的区别。<span class="hljs-title">虽然它们的`define()`方法的参数都相同，但是:</span>- `AMD`中会把当前模块的依赖模块放到`dependencies`中加载，并在`factory`回调中拿到加载成功的依赖- `CMD`一般不在`dependencies`中加载，而是写在`factory`中，使用`require`加载某个依赖模块因此才有了我们常常看到的一句话：&gt; AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块。（好吧，仔细读了<span class="hljs-number">2</span>遍感觉还是没太明白，没事，后面呆呆还会详细说到）比较有名一点的，`seajs`，来看看它推荐的CMD 模块书写格式吧：```js// 所有模块都通过 define 来定义  define(function(require, exports, module) &#123;      // 通过 require 引入依赖    var $ = require('jquery')<span class="hljs-comment">;  </span>  var Spinning = require('./spinning')<span class="hljs-comment">;  </span>    // 通过 exports 对外提供接口    exports.doSomething = ...      // 或者通过 module.exports 提供整个接口    module.exports = ...    &#125;)<span class="hljs-comment">;</span></code></pre></code></pre></li></ul><p>这是官网的一个小案例，我也去seajs的文档中看了一下没啥太大问题，这里就不举例了。</p><h2 id="AMD和CMD的区别"><a href="#AMD和CMD的区别" class="headerlink" title="AMD和CMD的区别"></a>AMD和CMD的区别</h2><blockquote><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块。</p></blockquote><p>还是上面那句话，让我们来看个小例子理解一下。</p><p>同样是<code>math</code>模块中需要加载<code>m1</code>模块。</p><p>在<code>AMD</code>中我们会这样写：</p><p><strong>math.js</strong></p><pre><code class="hljs js">define([<span class="hljs-string">'m1'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m1</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是math, 我被加载了...'</span>)    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(m1.name)    &#125;    <span class="hljs-keyword">return</span> &#123;      add: add,      print: print    &#125;  &#125;)</code></pre><p>但是对于<code>CMD</code>，我们会这样写：</p><p><strong>math.js</strong></p><pre><code class="hljs js">define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">require, exports, module</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是math, 我被加载了...'</span>)    <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'m1'</span>);    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(m1.name)    &#125;    <span class="hljs-built_in">module</span>.exports = &#123;      add: add,      print: print    &#125;  &#125;)</code></pre><p>假如此时<code>m1.js</code>中有一个语句是在<code>m1</code>模块被加载的时候打印出<code>&quot;我是m1, 我被加载了...&quot;</code>。</p><p>执行结果区别：</p><ul><li><code>AMD</code>，会先加载<code>m1</code>，<code>&quot;我是m1&quot;</code>会先执行</li><li><code>CMD</code>，我是<code>&quot;我是math&quot;</code>会先执行，因为本题中<code>console.log(&#39;我是math, 我被加载了...&#39;)</code>是放在<code>require(&#39;m1&#39;)</code>前面的。</li></ul><p>现在可以很明显的看到区别了。</p><p><code>AMD</code>依赖前置，<code>js</code>很方便的就知道要加载的是哪个模块了，因为已经在<code>define</code>的<code>dependencies</code>参数中就定义好了，会立即加载它。</p><p><code>CMD</code>是就近依赖，也就是说模块的回调函数执行到加载语句时才会去加载。</p><p>OK👌，来看个总结：</p><p>两者之间，最明显的区别就是在模块定义时对依赖的处理不同</p><p><strong>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块**</strong>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require**</p><h1 id="ES6-Modules规范"><a href="#ES6-Modules规范" class="headerlink" title="ES6 Modules规范"></a>ES6 Modules规范</h1><p><code>ES6</code>标准出来后，<code>ES6 Modules</code>规范算是成为了前端的主流吧，以<code>import</code>引入模块，<code>export</code>导出接口被越来越多的人使用。</p><p>下面，我也会从这么几个方面来介绍<code>ES6 Modules</code>规范：</p><p><code>export</code>命令和<code>import</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p><h2 id="1-export导出模块"><a href="#1-export导出模块" class="headerlink" title="1. export导出模块"></a>1. export导出模块</h2><p>export有两种模块导出方式：</p><ul><li>命名式导出(名称导出)</li><li>默认导出(自定义导出)</li></ul><p><strong>命名式导出</strong></p><p>来看几种正确和错误的写法吧：</p><pre><code class="hljs js"><span class="hljs-comment">// 以下两种为错误  </span><span class="hljs-comment">// 1.  </span><span class="hljs-keyword">export</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 2.  </span><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> a;    <span class="hljs-comment">// 以下为正确  </span><span class="hljs-comment">// 3.  </span><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> &#123; a &#125;;    <span class="hljs-comment">// 4. 接口名与模块内部变量之间，建立了一一对应的关系  </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 5. 接口名与模块内部变量之间，建立了一一对应的关系  </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 或者用 as 来命名  </span><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> &#123; a <span class="hljs-keyword">as</span> outA &#125;;    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;  <span class="hljs-keyword">export</span> &#123; a <span class="hljs-keyword">as</span> outA, b <span class="hljs-keyword">as</span> outB &#125;;</code></pre><p>容易混淆的可能是<code>2</code>和<code>4</code>两种写法了，看着很像，但是<code>2</code>却不行。<code>2</code>直接导出一个值为<code>1</code>的变量是和情况一一样，没有什么意义，因为你在后面要用的时候并不能完成解构。</p><p>但是<code>4</code>中，接口名与模块内部变量之间，建立了一一对应的关系，所以可以。</p><p><strong>默认导出</strong></p><p>默认导出会在<code>export</code>后面加上一个<code>default</code>：</p><pre><code class="hljs js"><span class="hljs-comment">// 1.  </span><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;    <span class="hljs-comment">// 2.  </span><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; a &#125;;    <span class="hljs-comment">// 3.  </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// 可以导出一个函数  </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span>()</span>&#123;&#125;; <span class="hljs-comment">// 也可以出一个类</span></code></pre><p>其实，默认导出可以理解为另一种形式上的命名导出，也就是说<code>a</code>这个属性名相当于是被我重写了成了<code>default</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;  <span class="hljs-keyword">export</span> defalut a;  <span class="hljs-comment">// 等价于  </span><span class="hljs-keyword">export</span> &#123; a <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;</code></pre><p>所以，我们才可以用<code>const a = 1; export default a;</code>这种方式导出一个值。</p><h2 id="2-import导入模块"><a href="#2-import导入模块" class="headerlink" title="2. import导入模块"></a>2. import导入模块</h2><p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p><p>来看看写法：</p><pre><code class="hljs js"><span class="hljs-comment">// 某个模块的导出 moudule.js  </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 模块导入  </span><span class="hljs-comment">// 1. 这里的a得和被加载的模块输出的接口名对应  </span><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>    <span class="hljs-comment">// 2. 使用 as 换名  </span><span class="hljs-keyword">import</span> &#123; a <span class="hljs-keyword">as</span> myA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>    <span class="hljs-comment">// 3. 若是只想要运行被加载的模块可以这样写，但是即使加载2次也只是运行一次  </span><span class="hljs-keyword">import</span> <span class="hljs-string">'./module'</span>    <span class="hljs-comment">// 4. 整体加载  </span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-built_in">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>    <span class="hljs-comment">// 5. default接口和具名接口  </span><span class="hljs-keyword">import</span> <span class="hljs-built_in">module</span>, &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span></code></pre><p>第四种写法会获取到<code>module</code>中所有导出的东西，并且赋值到<code>module</code>这个变量下，这样我们就可以用<code>module.a</code>这种方式来引用<code>a</code>了。</p><h2 id="3-export-…-from…"><a href="#3-export-…-from…" class="headerlink" title="3. export … from…"></a>3. export … from…</h2><p>其实还有一种写法，可以将<code>export</code>和<code>from</code>结合起来用。</p><p>例如，我有三个模块<code>a、b、c</code>。</p><p><code>c</code>模块现在想要引入<code>a</code>模块，但是它不不直接引用<code>a</code>，而是通过<code>b</code>模块来引用，那么你可能会想到<code>b</code>应该这样写：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; someVariable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a'</span>;    <span class="hljs-keyword">export</span> &#123; someVariable &#125;;</code></pre><p>引入<code>someVariable</code>然后再导出。</p><p>这还只是一个变量，我们得导入再导出，若是有很多个变量需要这样，那无疑会增加很多代码量。</p><p>所以这时候可以用下面这种方式来实现：</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; someVariable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a'</span>;</code></pre><p>不过这种方式有一点需要注意：</p><ul><li>这样的方式不会将数据添加到该聚合模块的作用域, 也就是说, 你无法在该模块(也就是<code>b</code>)中使用<code>someVariable</code>。</li></ul><h2 id="4-ES6-Modules规范的特点"><a href="#4-ES6-Modules规范的特点" class="headerlink" title="4. ES6 Modules规范的特点"></a>4. ES6 Modules规范的特点</h2><p>总结一下它的特点哈：</p><ul><li>输出使用<code>export</code></li><li>输入使用<code>import</code></li><li>可以使用<code>export...from...</code>这种写法来达到一个<code>&quot;中转&quot;</code>的效果</li><li>输入的模块变量是不可重新赋值的，它只是个可读引用，不过却可以改写属性</li><li><code>export</code>命令和<code>import</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</li><li><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</li></ul><h2 id="5-Bable下的ES6模块转换"><a href="#5-Bable下的ES6模块转换" class="headerlink" title="5. Bable下的ES6模块转换"></a>5. Bable下的ES6模块转换</h2><p>还有一点就是，如果你有使用过一些ES6的Babel的话，你会发现当使用<code>export/import</code>的时候，Babel也会把它转换为<code>exports/require</code>的形式。</p><p>例如我的输出：</p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span>;</code></pre><p>我的输入：</p><p><em>index.js</em>:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;count&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./m1.js'</span>  <span class="hljs-built_in">console</span>.log(count)</code></pre><p>当使用Babel编译之后，各自会被转换为：</p><p><em>m1.js</em>:</p><pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;    <span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, &#123;    value: <span class="hljs-literal">true</span>  &#125;);  exports.count = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span>;  exports.count = count;</code></pre><p><em>index.js</em>:</p><pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;    <span class="hljs-keyword">var</span> _m = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./m1.js"</span>);    <span class="hljs-built_in">console</span>.log(_m.count);</code></pre><p>正是因为这种转换关系，才能让我们把<code>exports</code>和<code>import</code>结合起来用：</p><p>也就是说你可以这样用：</p><pre><code class="hljs js"><span class="hljs-comment">// 输出模块 m1.js  </span>exports.count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// index.js中引入  </span><span class="hljs-keyword">import</span> &#123;count&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./m1.js'</span>  <span class="hljs-built_in">console</span>.log(count)</code></pre><h2 id="CommonJS与ES6-Modules规范的区别"><a href="#CommonJS与ES6-Modules规范的区别" class="headerlink" title="CommonJS与ES6 Modules规范的区别"></a>CommonJS与ES6 Modules规范的区别</h2><p>😂，我相信很多人就比较关心它两区别的问题，因为基本上面试问的就是这个。好吧，这里来做一个算是比较详细的总结吧。</p><ul><li>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li><li>CommonJS输出是值的浅拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li><li>CommonJS<code>this</code>指向当前模块，ES6 Modules<code>this</code>指向<code>undefined</code></li><li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul><p>关于第一个差异，是因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>（应该还一些区别我没想到的，欢迎补充👏😊）</p>]]></content>
    
    
    
    <tags>
      
      <tag>模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
